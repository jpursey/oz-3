################################################################################
## Shared macros to fetch word and dword values
################################################################################

# Returns a word value as a register.
#
# Modifies register "C2" and returns result in register "r".
macro(bits:5) GetWord:r {
  code:m "$r"          { UL; }
  code:C2 "($r)"       { UL; LKR(m); ADR(m); LD(C2); UL; }
  code:C2 "($r + $v)"  { LD(C2); UL; ADD(C2,m); LKR(m); ADR(C2); LD(C2); UL; }
  code:C2 "(SP)"       { UL; LKR(SP); ADR(SP); LD(C2); UL; }
  code:C2 "(SP + $v)"  { LD(C2); UL; ADD(C2,SP); LKR(SP); ADR(C2); LD(C2); UL; }
  code:C2 "(FP)"       { UL; LKR(FP); ADR(FP); LD(C2); UL; }
  code:C2 "(FP + $v)"  { LD(C2); UL; ADD(C2,FP); LKR(FP); ADR(C2); LD(C2); UL; }
  code:C2 "$v"         { LD(C2); UL; }
  code:C2 "S($v)"      { LD(C2); UL; LK(STACK); ADR(C2); LD(C2); UL; }
  code:C2 "D($v)"      { LD(C2); UL; LK(DATA); ADR(C2); LD(C2); UL; }
  code:C2 "E($v)"      { LD(C2); UL; LK(EXTRA); ADR(C2); LD(C2); UL; }
}

# Returns a dword value as a register.
#
# Modifies register "C0" and "C1" and returns result in register "R".
macro(bits:5) GetDword:R {
  code:M "$R" {
    UL;
  }
  code:CD "[$r]" {
    UL; LKR(m); ADR(m); LD(C0); LD(C1); UL;
  }
  code:CD "[$r + $v]" {
    LD(C0); UL; ADD(C0,m); LKR(m); ADR(C0); LD(C0); LD(C1); UL;
  }
  code:CD "[SP]" {
    UL; LKR(SP); ADR(SP); LD(C0); LD(C1); UL;
  }
  code:CD "[SP + $v]" {
    LD(C0); UL; ADD(C0,SP); LKR(SP); ADR(C0); LD(C0); LD(C1); UL;
  }
  code:CD "[FP]" {
    UL; LKR(FP); ADR(FP); LD(C0); LD(C1); UL;
  }
  code:CD "[FP + $v]" {
    LD(C0); UL; ADD(C0,FP); LKR(FP); ADR(C0); LD(C0); LD(C1); UL;
  }
  code:CD "$v" {
    LD(C0); UL;
  }
  code:CD "S[$v]" {
    LD(C0); UL; LK(STACK); ADR(C0); LD(C0); LD(C1); UL;
  }
  code:CD "D[$v]" {
    LD(C0); UL; LK(DATA); ADR(C0); LD(C0); LD(C1); UL;
  }
  code:CD "E[$v]" {
    LD(C0); UL; LK(EXTRA); ADR(C0); LD(C0); LD(C1); UL;
  }
}


################################################################################
## NOP
##
## Cycles: 3
## ZSCO: ----
##
## Minimal instruction that does nothing.
################################################################################

instruction(opcode:0) NOP {
  UL;
}

################################################################################
## HALT
##
## Cycles: 3
## ZSCO: ----
##
## Puts the core into the IDLE state. Interrupts will still be triggered and
## executed, but the core will stay idle until it is reset to a new code
## location.
################################################################################

instruction HALT {
  UL;
  ADDI(IP,-1);  # Reset IP so core stays halted after interrupt
  HALT;         # Put the core into idle state.
}

################################################################################
## WAIT <reg>
##
## Cycles: 3+ ()
## ZSCO: ---X
##
## Puts the core into the WAIT state for at least the number of cycles
## specified. Interrupts may still be executed during the WAIT state, but
## cannot recursively call WAIT themselves.
##
## After a successful WAIT execution (it was not called recursively from within
## an interrupt), the provided register will be update with the number of
## additional cycles taken. This may be longer than the requested time due to
## an interrupt occurring or the core getting locked.
##
## On failure, the O flag is set. Otherwise it is cleared.
################################################################################

instruction WAIT "$r" {
  UL;
  WAIT(a);
}

################################################################################
## MOV <dst> <src>
##
## Cycles: 4+
## ZSCO: ----
##
## Variants:
##    MOV.LW <reg> <word-value>
##    MOV.LD <dreg> <dword-value>
##    MOV.SW <word-address> <reg>
##    MOV.SD <dword-address> <dreg>
##    MOV.S  <sreg> <reg>
##    MOV.S  <reg> <sreg>
##
## Moves (copies) the value from from <src> into <dst>.
################################################################################

macro(bits:5) LoadWord(p) {
  code "$r"         { UL; MOV(p,m); }
  code "($r)"       { UL; LKR(m); ADR(m); LD(p); UL; }
  code "($r + $v)"  { LD(C0); UL; ADD(C0,m); LKR(m); ADR(C0); LD(p); UL; }
  code "(SP)"       { UL; LKR(SP); ADR(SP); LD(p); UL; }
  code "(SP + $v)"  { LD(C0); UL; ADD(C0,SP); LKR(SP); ADR(C0); LD(p); UL; }
  code "(FP)"       { UL; LKR(FP); ADR(FP); LD(p); UL; }
  code "(FP + $v)"  { LD(C0); UL; ADD(C0,FP); LKR(FP); ADR(C0); LD(p); UL; }
  code "$v"         { LD(p); UL; }
  code "S($v)"      { LD(C0); UL; LK(STACK); ADR(C0); LD(p); UL; }
  code "D($v)"      { LD(C0); UL; LK(DATA); ADR(C0); LD(p); UL; }
  code "E($v)"      { LD(C0); UL; LK(EXTRA); ADR(C0); LD(p); UL; }
}

instruction MOV.LW "$r, $m" {
  $LoadWord(a);
}

macro(bits:5) LoadDword(P) {
  code "$R" {
    UL; MOV(p0,m0); MOV(p1,m1);
  }
  code "[$r]" {
    UL; LKR(m); ADR(m); LD(p0); LD(p1); UL;
  }
  code "[$r + $v]" {
    LD(C0); UL; ADD(C0,m); LKR(m); ADR(C0); LD(p0); LD(p1); UL;
  }
  code "[SP]" {
    UL; LKR(SP); ADR(SP); LD(p0); LD(p1); UL;
  }
  code "[SP + $v]" {
    LD(C0); UL; ADD(C0,SP); LKR(SP); ADR(C0); LD(p0); LD(p1); UL;
  }
  code "[FP]" {
    UL; LKR(FP); ADR(FP); LD(p0); LD(p1); UL;
  }
  code "[FP + $v]" {
    LD(C0); UL; ADD(C0,FP); LKR(FP); ADR(C0); LD(p0); LD(p1); UL;
  }
  code "$V" {
    LD(p0); LD(p1); UL;
  }
  code "S[$v]" {
    LD(C0); UL; LK(STACK); ADR(C0); LD(p0); LD(p1); UL;
  }
  code "D[$v]" {
    LD(C0); UL; LK(DATA); ADR(C0); LD(p0); LD(p1); UL;
  }
  code "E[$v]" {
    LD(C0); UL; LK(EXTRA); ADR(C0); LD(p0); LD(p1); UL;
  }
}

instruction MOV.LD "$R, $m" {
  $LoadDword(A);
}

macro(bits:5) StoreWord(p) {
  code "($r)"       { UL; LKR(m); ADR(m); ST(p); UL; }
  code "($r + $v)"  { LD(C0); UL; ADD(C0,m); LKR(m); ADR(C0); ST(p); UL; }
  code "(SP)"       { UL; LKR(SP); ADR(SP); ST(p); UL; }
  code "(SP + $v)"  { LD(C0); UL; ADD(C0,SP); LKR(SP); ADR(C0); ST(p); UL; }
  code "(FP)"       { UL; LKR(FP); ADR(FP); ST(p); UL; }
  code "(FP + $v)"  { LD(C0); UL; ADD(C0,FP); LKR(FP); ADR(C0); ST(p); UL; }
  code "S($v)"      { LD(C0); UL; LK(STACK); ADR(C0); ST(p); UL; }
  code "D($v)"      { LD(C0); UL; LK(DATA); ADR(C0); ST(p); UL; }
  code "E($v)"      { LD(C0); UL; LK(EXTRA); ADR(C0); ST(p); UL; }
}

instruction MOV.SW "$m, $r" {
  $StoreWord(b);
}

macro(bits:5) StoreDword(P) {
  code "[$r]" {
    UL; LKR(m); ADR(m); ST(p0); ST(p1); UL;
  }
  code "[$r + $v]" {
    LD(C0); UL; ADD(C0,m); LKR(m); ADR(C0); ST(p0); ST(p1); UL;
  }
  code "[SP]" {
    UL; LKR(SP); ADR(SP); ST(p0); ST(p1); UL;
  }
  code "[SP + $v]" {
    LD(C0); UL; ADD(C0,SP); LKR(SP); ADR(C0); ST(p0); ST(p1); UL;
  }
  code "[FP]" {
    UL; LKR(FP); ADR(FP); ST(p0); ST(p1); UL;
  }
  code "[FP + $v]" {
    LD(C0); UL; ADD(C0,FP); LKR(FP); ADR(C0); ST(p0); ST(p1); UL;
  }
  code "S[$v]" {
    LD(C0); UL; LK(STACK); ADR(C0); ST(p0); ST(p1); UL;
  }
  code "D[$v]" {
    LD(C0); UL; LK(DATA); ADR(C0); ST(p0); ST(p1); UL;
  }
  code "E[$v]" {
    LD(C0); UL; LK(EXTRA); ADR(C0); ST(p0); ST(p1); UL;
  }
}

instruction MOV.SD "$m, $R" {
  $StoreDword(B);
}

macro MoveSReg {
  code "$r, BC" { UL; MOV(m,BC); }
  code "$r, BS" { UL; MOV(m,BS); }
  code "$r, BD" { UL; MOV(m,BD); }
  code "$r, BE" { UL; MOV(m,BE); }
  code "$r, FP" { UL; MOV(m,FP); }
  code "$r, SP" { UL; MOV(m,SP); }
  code "BC, $r" { UL; MOV(BC,m); }
  code "BS, $r" { UL; MOV(BS,m); }
  code "BD, $r" { UL; MOV(BD,m); }
  code "BE, $r" { UL; MOV(BE,m); }
  code "FP, $r" { UL; MOV(FP,m); }
  code "SP, $r" { UL; MOV(SP,m); }
  code "BC, $v" { LD(C0); UL; MOV(BC,C0); }
  code "BS, $v" { LD(C0); UL; MOV(BS,C0); }
  code "BD, $v" { LD(C0); UL; MOV(BD,C0); }
  code "BE, $v" { LD(C0); UL; MOV(BE,C0); }
  code "FP, $v" { LD(C0); UL; MOV(FP,C0); }
  code "SP, $v" { LD(C0); UL; MOV(SP,C0); }
}

instruction MOV.S "$m" {
  $MoveSReg;
}

################################################################################
## MVQ <dst> <value>
##
## Cycles: 4-5
## ZSCO: ----
##
## Variants:
##    MVQ.LW <reg> <0..31>
##    MVQ.LD <dreg> <0..31>
##
## Moves the immediate value in the range [0,31] to the specified register.
################################################################################

instruction MVQ.LW "$r, $#5" {
  UL; MOV(a,C1);
}

instruction MVQ.LD "$R, $#5" {
  UL; MOV(a0,C1); MOVI(a1,0);
}

################################################################################
## SWP <a> <b>
##
## Cycles: 6+
## ZSCO: ----
##
## Variants:
##    SWP.W <reg> <reg>
##    SWP.W <reg> <word-address>
##    SWP.D <dreg> <dreg>
##    SWP.D <dreg> <dword-address>
##
## Swaps the contents of the specified register <a> with a register or memory
## address value <b>
################################################################################

macro SwapWord(p) {
  code "$r" {
    UL;
    MOV(C0,p); MOV(p,m); MOV(m,C0);
  }
  code "($r)" {
    UL;
    MOV(C0,p); LKR(m); ADR(m); LD(p); STP(C0); UL;
  }
  code "($r + $v)" {
    LD(C2); UL; ADD(C2,m);
    MOV(C0,p); LKR(m); ADR(C2); LD(p); STP(C0); UL;
  }
  code "(SP)" {
    UL;
    MOV(C0,p); LKR(SP); ADR(SP); LD(p); STP(C0); UL;
  }
  code "(SP + $v)" {
    LD(C2); UL; ADD(C2,SP);
    MOV(C0,p); LKR(SP); ADR(C2); LD(p); STP(C0); UL;
  }
  code "(FP)" {
    UL;
    MOV(C0,p); LKR(FP); ADR(FP); LD(p); STP(C0); UL;
  }
  code "(FP + $v)" {
    LD(C2); UL; ADD(C2,FP);
    MOV(C0,p); LKR(FP); ADR(C2); LD(p); STP(C0); UL;
  }
  code "S($v)" {
    LD(C2); UL;
    MOV(C0,p); LK(STACK); ADR(C2); LD(p); STP(C0); UL;
  }
  code "D($v)" {
    LD(C2); UL;
    MOV(C0,p); LK(DATA); ADR(C2); LD(p); STP(C0); UL;
  }
  code "E($v)" {
    LD(C2); UL;
    MOV(C0,p); LK(EXTRA); ADR(C2); LD(p); STP(C0); UL;
  }
}

instruction SWP.W "$r, $m" {
  $SwapWord(a);
}

macro SwapDword(P) {
  code "$R" {
    UL;
    MOV(C0,p0); MOV(p0,m0); MOV(m0,C0);
    MOV(C1,p1); MOV(p1,m1); MOV(m1,C1);
  }
  code "($r)" {
    UL;
    MOV(C0,p0); MOV(C1,p1);
    LKR(m); ADR(m); LD(p0); LD(p1); STP(C1); STP(C0); UL;
  }
  code "($r + $v)" {
    LD(C2); UL; ADD(C2,m);
    MOV(C0,p0); MOV(C1,p1);
    LKR(m); ADR(C2); LD(p0); LD(p1); STP(C1); STP(C0); UL;
  }
  code "(SP)" {
    UL;
    MOV(C0,p0); MOV(C1,p1);
    LKR(SP); ADR(SP); LD(p0); LD(p1); STP(C1); STP(C0); UL;
  }
  code "(SP + $v)" {
    LD(C2); UL; ADD(C2,SP);
    MOV(C0,p0); MOV(C1,p1);
    LKR(SP); ADR(C2); LD(p0); LD(p1); STP(C1); STP(C0); UL;
  }
  code "(FP)" {
    UL;
    MOV(C0,p0); MOV(C1,p1);
    LKR(FP); ADR(FP); LD(p0); LD(p1); STP(C1); STP(C0); UL;
  }
  code "(FP + $v)" {
    LD(C2); UL; ADD(C2,FP);
    MOV(C0,p0); MOV(C1,p1);
    LKR(FP); ADR(C2); LD(p0); LD(p1); STP(C1); STP(C0); UL;
  }
  code "S($v)" {
    LD(C2); UL;
    MOV(C0,p0); MOV(C1,p1);
    LK(STACK); ADR(C2); LD(p0); LD(p1); STP(C1); STP(C0); UL;
  }
  code "D($v)" {
    LD(C2); UL;
    MOV(C0,p0); MOV(C1,p1);
    LK(DATA); ADR(C2); LD(p0); LD(p1); STP(C1); STP(C0); UL;
  }
  code "E($v)" {
    LD(C2); UL;
    MOV(C0,p0); MOV(C1,p1);
    LK(EXTRA); ADR(C2); LD(p0); LD(p1); STP(C1); STP(C0); UL;
  }
}

instruction SWP.D "$R, $m" {
  $SwapDword(A);
}


################################################################################
## NEG <register>
##
## Cycles: 5-9
## ZSCO: XX00
##
## Variants:
##    NEG.W <reg>
##    NEG.D <dreg>
##
## Negates the value in the specified register.
################################################################################

instruction NEG.W "$r" {
  UL;
  # The contract is to always clear the CO flags, which SUB won't do, so we need
  # to clear them explicitly before returning the status
  SUB(C0,a); MSC(CO); MSR(ZSCO,ZSCO);

  # Copy result back to the register
  MOV(a,C0);
}

instruction NEG.D "$R" {
  UL;

  # Proactively set zero bit here based on low-order result.
  SUB(C0,a0); MSR(Z,Z);

  # Clear the zero bit (but don't set it) based on high-order result.
  SBC(C1,a1); MSC(CO); MSR(ZSCO,_SCO);

  # Copy result back to the register
  MOV(a0,C0); MOV(a1,C1);
}

################################################################################
## ADD <register>, <value>
##
## Cycles: 4+
## ZSCO: XXXX
##
## Variants:
##    ADD.W <reg>, <word-value>
##    ADD.D <dreg>, <dword-value>
##
## Adds a value to the specified register.
################################################################################

instruction ADD.W "$r, $m" {
  $GetWord;
  ADD(a,r);
  MSR(ZSCO,ZSCO);
}

instruction ADD.D "$R, $m" {
  $GetDword;
  ADD(a0,r0);
  MSR(Z,Z);
  ADC(a1,r1);
  MSR(ZSCO,_SCO);
}

################################################################################
## ADQ <register>, <value>
##
## Cycles: 4-5
## ZSCO: XXXX
##
## Variants:
##    ADD.W <reg>, <0..31>
##    ADD.D <dreg>, <0..31>
##
## Adds a value to the specified register.
################################################################################

instruction ADQ.W "$r, $#5" {
  UL;
  ADD(a,C1);
  MSR(ZSCO,ZSCO);
}

instruction ADQ.D "$R, $#5" {
  UL;
  ADD(a0,C1);
  MSR(Z,Z);
  ADC(a1,C2);
  MSR(ZSCO,_SCO);
}

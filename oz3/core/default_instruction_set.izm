################################################################################
## Shared macros to fetch word and dword values
################################################################################

# Returns a word value as a register.
#
# Ends fetch phase.
# Modifies register "C2" and returns result in register "r".
macro(bits:5) GetWord:r {
  code:m "$r"          { UL; }
  code:C2 "($r)"       { UL; LKR(m); ADR(m); LD(C2); UL; }
  code:C2 "($r + $v)"  { LD(C2); UL; ADD(C2,m); LKR(m); ADR(C2); LD(C2); UL; }
  code:C2 "(SP)"       { UL; LKR(SP); ADR(SP); LD(C2); UL; }
  code:C2 "(SP + $v)"  { LD(C2); UL; ADD(C2,SP); LKR(SP); ADR(C2); LD(C2); UL; }
  code:C2 "(FP)"       { UL; LKR(FP); ADR(FP); LD(C2); UL; }
  code:C2 "(FP + $v)"  { LD(C2); UL; ADD(C2,FP); LKR(FP); ADR(C2); LD(C2); UL; }
  code:C2 "$v"         { LD(C2); UL; }
  code:C2 "S($v)"      { LD(C2); UL; LK(STACK); ADR(C2); LD(C2); UL; }
  code:C2 "D($v)"      { LD(C2); UL; LK(DATA); ADR(C2); LD(C2); UL; }
  code:C2 "E($v)"      { LD(C2); UL; LK(EXTRA); ADR(C2); LD(C2); UL; }
}

# Returns a dword value as a register.
#
# Ends fetch phase.
# Modifies register "C0" and "C1" and returns result in register "R".
macro(bits:5) GetDword:R {
  code:M "$R" {
    UL;
  }
  code:CD "[$r]" {
    UL; LKR(m); ADR(m); LD(C0); LD(C1); UL;
  }
  code:CD "[$r + $v]" {
    LD(C0); UL; ADD(C0,m); LKR(m); ADR(C0); LD(C0); LD(C1); UL;
  }
  code:CD "[SP]" {
    UL; LKR(SP); ADR(SP); LD(C0); LD(C1); UL;
  }
  code:CD "[SP + $v]" {
    LD(C0); UL; ADD(C0,SP); LKR(SP); ADR(C0); LD(C0); LD(C1); UL;
  }
  code:CD "[FP]" {
    UL; LKR(FP); ADR(FP); LD(C0); LD(C1); UL;
  }
  code:CD "[FP + $v]" {
    LD(C0); UL; ADD(C0,FP); LKR(FP); ADR(C0); LD(C0); LD(C1); UL;
  }
  code:CD "$v" {
    LD(C0); UL;
  }
  code:CD "S[$v]" {
    LD(C0); UL; LK(STACK); ADR(C0); LD(C0); LD(C1); UL;
  }
  code:CD "D[$v]" {
    LD(C0); UL; LK(DATA); ADR(C0); LD(C0); LD(C1); UL;
  }
  code:CD "E[$v]" {
    LD(C0); UL; LK(EXTRA); ADR(C0); LD(C0); LD(C1); UL;
  }
}

# Returns a 16-bit mask for a specified bit position (0-15) otherwise
# returns zero
#
# Ends fetch phase.
# Requires C1=0
# Modifies C0, C2.
macro(bits:5) Get16BitMask:r {
  code:C0 "$r" {
    UL;
    MOV(C2,m);
    MOVI(C0,1);
    CMP(C1,m);
    JC(Z,@done);
  @shift:
    SL(C0);
    JD(C2,@shift);
  @done: MSS(_);
  }

  code:C0 "0"  { UL; MOVI(C0,0x01); }
  code:C0 "1"  { UL; MOVI(C0,0x02); }
  code:C0 "2"  { UL; MOVI(C0,0x04); }
  code:C0 "3"  { UL; MOVI(C0,0x08); }
  code:C0 "4"  { UL; MOVI(C0,0x10); }
  code:C0 "5"  { UL; MOVI(C0,0x20); }
  code:C0 "6"  { UL; MOVI(C0,0x40); }
  code:C0 "7"  {
    UL; MOVI(C0,0x40);
    SL(C0);
  }
  code:C0 "8"  {
    UL; MOVI(C0,0x40);
    SL(C0); SL(C0);
  }
  code:C0 "9"  {
    UL; MOVI(C0,0x40);
    SL(C0); SL(C0); SL(C0);
  }
  code:C0 "10" {
    UL; MOVI(C0,0x40);
    SL(C0); SL(C0); SL(C0); SL(C0);
  }
  code:C0 "11" {
    UL; MOVI(C0,0x40);
    SL(C0); SL(C0); SL(C0); SL(C0); SL(C0);
  }
  code:C0 "12" {
    UL; MOVI(C0,0x40);
    SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0);
  }
  code:C0 "13" {
    UL; MOVI(C0,0x40);
    SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0);
  }
  code:C0 "14" {
    UL; MOVI(C0,0x40);
    SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0);
  }
  code:C0 "15" {
    UL; MOVI(C0,0x40);
    SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0);
  }
}

# Returns a 32-bit mask for a specified bit position (0-31) otherwise
# returns zero
#
# Ends fetch phase.
# Requires: C0=0 and C1=0
# Modifies: C0, C1, C2
macro(bits:6) Get32BitMask:R {
  code:CD "$r" {
    UL;
    MOVI(C2,16);
    CMP(C2,m);
    JC(S,@upper);
    JC(Z,@sixteen);
    MOVI(C0,1);
    CMP(C1,m);
    JC(Z,@done);
    MOV(C2,m);
  @shift_lower:
    SL(C0);
    JD(C2,@shift_lower);
    JP(@done);
  @sixteen:
    MOVI(C1,1);
    JP(@done);
  @upper:
    MOV(C2,m);
    ADDI(C2,-16);
    MOVI(C1,1);
    CMP(C0,C2);
    JC(Z,@done);
  @shift_upper:
    SL(C1);
    JD(C2,@shift_upper);
  @done: MSS(_);
  }

  code:CD "0"  { UL; MOVI(C0,0x0001); }
  code:CD "1"  { UL; MOVI(C0,0x0002); }
  code:CD "2"  { UL; MOVI(C0,0x0004); }
  code:CD "3"  { UL; MOVI(C0,0x0008); }
  code:CD "4"  { UL; MOVI(C0,0x0010); }
  code:CD "5"  { UL; MOVI(C0,0x0020); }
  code:CD "6"  { UL; MOVI(C0,0x0040); }
  code:CD "7"  {
    UL; MOVI(C0,0x0040);
    SL(C0);
  }
  code:CD "8"  {
    UL; MOVI(C0,0x0040);
    SL(C0); SL(C0);
  }
  code:CD "9"  {
    UL; MOVI(C0,0x0040);
    SL(C0); SL(C0); SL(C0);
  }
  code:CD "10" {
    UL; MOVI(C0,0x0040);
    SL(C0); SL(C0); SL(C0); SL(C0);
  }
  code:CD "11" {
    UL; MOVI(C0,0x0040);
    SL(C0); SL(C0); SL(C0); SL(C0); SL(C0);
  }
  code:CD "12" {
    UL; MOVI(C0,0x0040);
    SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0);
  }
  code:CD "13" {
    UL; MOVI(C0,0x0040);
    SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0);
  }
  code:CD "14" {
    UL; MOVI(C0,0x0040);
    SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0);
  }
  code:CD "15" {
    UL; MOVI(C0,0x0040);
    SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0);
  }
  code:CD "16"  { UL; MOVI(C1,0x0001); }
  code:CD "17"  { UL; MOVI(C1,0x0002); }
  code:CD "18"  { UL; MOVI(C1,0x0004); }
  code:CD "19"  { UL; MOVI(C1,0x0008); }
  code:CD "20"  { UL; MOVI(C1,0x0010); }
  code:CD "21"  { UL; MOVI(C1,0x0020); }
  code:CD "22"  { UL; MOVI(C1,0x0040); }
  code:CD "23"  {
    UL; MOVI(C1,0x0040);
    SL(C1);
  }
  code:CD "24"  {
    UL; MOVI(C1,0x0040);
    SL(C1); SL(C1);
  }
  code:CD "25"  {
    UL; MOVI(C1,0x0040);
    SL(C1); SL(C1); SL(C1);
  }
  code:CD "26" {
    UL; MOVI(C1,0x0040);
    SL(C1); SL(C1); SL(C1); SL(C1);
  }
  code:CD "27" {
    UL; MOVI(C1,0x0040);
    SL(C1); SL(C1); SL(C1); SL(C1); SL(C1);
  }
  code:CD "28" {
    UL; MOVI(C1,0x0040);
    SL(C1); SL(C1); SL(C1); SL(C1); SL(C1); SL(C1);
  }
  code:CD "29" {
    UL; MOVI(C1,0x0040);
    SL(C1); SL(C1); SL(C1); SL(C1); SL(C1); SL(C1); SL(C1);
  }
  code:CD "30" {
    UL; MOVI(C1,0x0040);
    SL(C1); SL(C1); SL(C1); SL(C1); SL(C1); SL(C1); SL(C1); SL(C1);
  }
  code:CD "31" {
    UL; MOVI(C1,0x0040);
    SL(C1); SL(C1); SL(C1); SL(C1); SL(C1); SL(C1); SL(C1); SL(C1); SL(C1);
  }
}

################################################################################
## NOP
##
## Cycles: 3
## ZSCO: ----
##
## Minimal instruction that does nothing.
################################################################################

instruction(opcode:0) NOP {
  UL;
}

################################################################################
## HALT
##
## Cycles: 3
## ZSCO: ----
##
## Puts the core into the IDLE state. Interrupts will still be triggered and
## executed, but the core will stay idle until it is reset to a new code
## location.
################################################################################

instruction HALT {
  UL;
  ADDI(IP,-1);  # Reset IP so core stays halted after interrupt
  HALT;         # Put the core into idle state.
}

################################################################################
## WAIT <reg>
##
## Cycles: 3+ ()
## ZSCO: ---X
##
## Puts the core into the WAIT state for at least the number of cycles
## specified. Interrupts may still be executed during the WAIT state, but
## cannot recursively call WAIT themselves.
##
## After a successful WAIT execution (it was not called recursively from within
## an interrupt), the provided register will be update with the number of
## additional cycles taken. This may be longer than the requested time due to
## an interrupt occurring or the core getting locked.
##
## On failure, the O flag is set. Otherwise it is cleared.
################################################################################

instruction WAIT "$r" {
  UL;
  WAIT(a);
}

################################################################################
## MOV <dst> <src>
##
## Cycles: 4+
## ZSCO: ----
##
## Variants:
##    MOV.LW <reg> <word-value>
##    MOV.LD <dreg> <dword-value>
##    MOV.SW <word-address> <reg>
##    MOV.SD <dword-address> <dreg>
##    MOV.S  <sreg> <reg>
##    MOV.S  <reg> <sreg>
##
## Moves (copies) the value from from <src> into <dst>.
################################################################################

macro(bits:5) LoadWord(p) {
  code "$r"         { UL; MOV(p,m); }
  code "($r)"       { UL; LKR(m); ADR(m); LD(p); UL; }
  code "($r + $v)"  { LD(C0); UL; ADD(C0,m); LKR(m); ADR(C0); LD(p); UL; }
  code "(SP)"       { UL; LKR(SP); ADR(SP); LD(p); UL; }
  code "(SP + $v)"  { LD(C0); UL; ADD(C0,SP); LKR(SP); ADR(C0); LD(p); UL; }
  code "(FP)"       { UL; LKR(FP); ADR(FP); LD(p); UL; }
  code "(FP + $v)"  { LD(C0); UL; ADD(C0,FP); LKR(FP); ADR(C0); LD(p); UL; }
  code "$v"         { LD(p); UL; }
  code "S($v)"      { LD(C0); UL; LK(STACK); ADR(C0); LD(p); UL; }
  code "D($v)"      { LD(C0); UL; LK(DATA); ADR(C0); LD(p); UL; }
  code "E($v)"      { LD(C0); UL; LK(EXTRA); ADR(C0); LD(p); UL; }
}

instruction MOV.LW "$r, $m" {
  $LoadWord(a);
}

macro(bits:5) LoadDword(P) {
  code "$R" {
    UL; MOV(p0,m0); MOV(p1,m1);
  }
  code "[$r]" {
    UL; LKR(m); ADR(m); LD(p0); LD(p1); UL;
  }
  code "[$r + $v]" {
    LD(C0); UL; ADD(C0,m); LKR(m); ADR(C0); LD(p0); LD(p1); UL;
  }
  code "[SP]" {
    UL; LKR(SP); ADR(SP); LD(p0); LD(p1); UL;
  }
  code "[SP + $v]" {
    LD(C0); UL; ADD(C0,SP); LKR(SP); ADR(C0); LD(p0); LD(p1); UL;
  }
  code "[FP]" {
    UL; LKR(FP); ADR(FP); LD(p0); LD(p1); UL;
  }
  code "[FP + $v]" {
    LD(C0); UL; ADD(C0,FP); LKR(FP); ADR(C0); LD(p0); LD(p1); UL;
  }
  code "$V" {
    LD(p0); LD(p1); UL;
  }
  code "S[$v]" {
    LD(C0); UL; LK(STACK); ADR(C0); LD(p0); LD(p1); UL;
  }
  code "D[$v]" {
    LD(C0); UL; LK(DATA); ADR(C0); LD(p0); LD(p1); UL;
  }
  code "E[$v]" {
    LD(C0); UL; LK(EXTRA); ADR(C0); LD(p0); LD(p1); UL;
  }
}

instruction MOV.LD "$R, $m" {
  $LoadDword(A);
}

macro(bits:5) StoreWord(p) {
  code "($r)"       { UL; LKR(m); ADR(m); ST(p); UL; }
  code "($r + $v)"  { LD(C0); UL; ADD(C0,m); LKR(m); ADR(C0); ST(p); UL; }
  code "(SP)"       { UL; LKR(SP); ADR(SP); ST(p); UL; }
  code "(SP + $v)"  { LD(C0); UL; ADD(C0,SP); LKR(SP); ADR(C0); ST(p); UL; }
  code "(FP)"       { UL; LKR(FP); ADR(FP); ST(p); UL; }
  code "(FP + $v)"  { LD(C0); UL; ADD(C0,FP); LKR(FP); ADR(C0); ST(p); UL; }
  code "S($v)"      { LD(C0); UL; LK(STACK); ADR(C0); ST(p); UL; }
  code "D($v)"      { LD(C0); UL; LK(DATA); ADR(C0); ST(p); UL; }
  code "E($v)"      { LD(C0); UL; LK(EXTRA); ADR(C0); ST(p); UL; }
}

instruction MOV.SW "$m, $r" {
  $StoreWord(b);
}

macro(bits:5) StoreDword(P) {
  code "[$r]" {
    UL; LKR(m); ADR(m); ST(p0); ST(p1); UL;
  }
  code "[$r + $v]" {
    LD(C0); UL; ADD(C0,m); LKR(m); ADR(C0); ST(p0); ST(p1); UL;
  }
  code "[SP]" {
    UL; LKR(SP); ADR(SP); ST(p0); ST(p1); UL;
  }
  code "[SP + $v]" {
    LD(C0); UL; ADD(C0,SP); LKR(SP); ADR(C0); ST(p0); ST(p1); UL;
  }
  code "[FP]" {
    UL; LKR(FP); ADR(FP); ST(p0); ST(p1); UL;
  }
  code "[FP + $v]" {
    LD(C0); UL; ADD(C0,FP); LKR(FP); ADR(C0); ST(p0); ST(p1); UL;
  }
  code "S[$v]" {
    LD(C0); UL; LK(STACK); ADR(C0); ST(p0); ST(p1); UL;
  }
  code "D[$v]" {
    LD(C0); UL; LK(DATA); ADR(C0); ST(p0); ST(p1); UL;
  }
  code "E[$v]" {
    LD(C0); UL; LK(EXTRA); ADR(C0); ST(p0); ST(p1); UL;
  }
}

instruction MOV.SD "$m, $R" {
  $StoreDword(B);
}

macro MoveSReg {
  code "$r, BC" { UL; MOV(m,BC); }
  code "$r, BS" { UL; MOV(m,BS); }
  code "$r, BD" { UL; MOV(m,BD); }
  code "$r, BE" { UL; MOV(m,BE); }
  code "$r, FP" { UL; MOV(m,FP); }
  code "$r, SP" { UL; MOV(m,SP); }
  code "BC, $r" { UL; MOV(BC,m); }
  code "BS, $r" { UL; MOV(BS,m); }
  code "BD, $r" { UL; MOV(BD,m); }
  code "BE, $r" { UL; MOV(BE,m); }
  code "FP, $r" { UL; MOV(FP,m); }
  code "SP, $r" { UL; MOV(SP,m); }
  code "BC, $v" { LD(C0); UL; MOV(BC,C0); }
  code "BS, $v" { LD(C0); UL; MOV(BS,C0); }
  code "BD, $v" { LD(C0); UL; MOV(BD,C0); }
  code "BE, $v" { LD(C0); UL; MOV(BE,C0); }
  code "FP, $v" { LD(C0); UL; MOV(FP,C0); }
  code "SP, $v" { LD(C0); UL; MOV(SP,C0); }
}

instruction MOV.S "$m" {
  $MoveSReg;
}

################################################################################
## MVQ <dst> <value>
##
## Cycles: 4-5
## ZSCO: ----
##
## Variants:
##    MVQ.LW <reg> <0..31>
##    MVQ.LD <dreg> <0..31>
##
## Moves the immediate value in the range [0,31] to the specified register.
################################################################################

instruction MVQ.LW "$r, $#5" {
  UL; MOV(a,C1);
}

instruction MVQ.LD "$R, $#5" {
  UL; MOV(a0,C1); MOVI(a1,0);
}

################################################################################
## SWP <a> <b>
##
## Cycles: 6+
## ZSCO: ----
##
## Variants:
##    SWP.W <reg> <reg>
##    SWP.W <reg> <word-address>
##    SWP.D <dreg> <dreg>
##    SWP.D <dreg> <dword-address>
##
## Swaps the contents of the specified register <a> with a register or memory
## address value <b>
################################################################################

macro SwapWord(p) {
  code "$r" {
    UL;
    MOV(C0,p); MOV(p,m); MOV(m,C0);
  }
  code "($r)" {
    UL;
    MOV(C0,p); LKR(m); ADR(m); LD(p); STP(C0); UL;
  }
  code "($r + $v)" {
    LD(C2); UL; ADD(C2,m);
    MOV(C0,p); LKR(m); ADR(C2); LD(p); STP(C0); UL;
  }
  code "(SP)" {
    UL;
    MOV(C0,p); LKR(SP); ADR(SP); LD(p); STP(C0); UL;
  }
  code "(SP + $v)" {
    LD(C2); UL; ADD(C2,SP);
    MOV(C0,p); LKR(SP); ADR(C2); LD(p); STP(C0); UL;
  }
  code "(FP)" {
    UL;
    MOV(C0,p); LKR(FP); ADR(FP); LD(p); STP(C0); UL;
  }
  code "(FP + $v)" {
    LD(C2); UL; ADD(C2,FP);
    MOV(C0,p); LKR(FP); ADR(C2); LD(p); STP(C0); UL;
  }
  code "S($v)" {
    LD(C2); UL;
    MOV(C0,p); LK(STACK); ADR(C2); LD(p); STP(C0); UL;
  }
  code "D($v)" {
    LD(C2); UL;
    MOV(C0,p); LK(DATA); ADR(C2); LD(p); STP(C0); UL;
  }
  code "E($v)" {
    LD(C2); UL;
    MOV(C0,p); LK(EXTRA); ADR(C2); LD(p); STP(C0); UL;
  }
}

instruction SWP.W "$r, $m" {
  $SwapWord(a);
}

macro SwapDword(P) {
  code "$R" {
    UL;
    MOV(C0,p0); MOV(p0,m0); MOV(m0,C0);
    MOV(C1,p1); MOV(p1,m1); MOV(m1,C1);
  }
  code "($r)" {
    UL;
    MOV(C0,p0); MOV(C1,p1);
    LKR(m); ADR(m); LD(p0); LD(p1); STP(C1); STP(C0); UL;
  }
  code "($r + $v)" {
    LD(C2); UL; ADD(C2,m);
    MOV(C0,p0); MOV(C1,p1);
    LKR(m); ADR(C2); LD(p0); LD(p1); STP(C1); STP(C0); UL;
  }
  code "(SP)" {
    UL;
    MOV(C0,p0); MOV(C1,p1);
    LKR(SP); ADR(SP); LD(p0); LD(p1); STP(C1); STP(C0); UL;
  }
  code "(SP + $v)" {
    LD(C2); UL; ADD(C2,SP);
    MOV(C0,p0); MOV(C1,p1);
    LKR(SP); ADR(C2); LD(p0); LD(p1); STP(C1); STP(C0); UL;
  }
  code "(FP)" {
    UL;
    MOV(C0,p0); MOV(C1,p1);
    LKR(FP); ADR(FP); LD(p0); LD(p1); STP(C1); STP(C0); UL;
  }
  code "(FP + $v)" {
    LD(C2); UL; ADD(C2,FP);
    MOV(C0,p0); MOV(C1,p1);
    LKR(FP); ADR(C2); LD(p0); LD(p1); STP(C1); STP(C0); UL;
  }
  code "S($v)" {
    LD(C2); UL;
    MOV(C0,p0); MOV(C1,p1);
    LK(STACK); ADR(C2); LD(p0); LD(p1); STP(C1); STP(C0); UL;
  }
  code "D($v)" {
    LD(C2); UL;
    MOV(C0,p0); MOV(C1,p1);
    LK(DATA); ADR(C2); LD(p0); LD(p1); STP(C1); STP(C0); UL;
  }
  code "E($v)" {
    LD(C2); UL;
    MOV(C0,p0); MOV(C1,p1);
    LK(EXTRA); ADR(C2); LD(p0); LD(p1); STP(C1); STP(C0); UL;
  }
}

instruction SWP.D "$R, $m" {
  $SwapDword(A);
}


################################################################################
## NEG <register>
##
## Cycles: 5-9
## ZSCO: XX00
##
## Variants:
##    NEG.W <reg>
##    NEG.D <dreg>
##
## Negates the value in the specified register.
################################################################################

instruction NEG.W "$r" {
  UL;
  # The contract is to always clear the CO flags, which SUB won't do, so we need
  # to clear them explicitly before returning the status
  SUB(C0,a); MSC(CO); MSR(ZSCO,ZSCO);

  # Copy result back to the register
  MOV(a,C0);
}

instruction NEG.D "$R" {
  UL;

  # Proactively set zero bit here based on low-order result.
  SUB(C0,a0); MSR(Z,Z);

  # Clear the zero bit (but don't set it) based on high-order result.
  SBC(C1,a1); MSC(CO); MSR(ZSCO,_SCO);

  # Copy result back to the register
  MOV(a0,C0); MOV(a1,C1);
}

################################################################################
## ADD <register>, <value>
##
## Cycles: 4+
## ZSCO: XXXX
##
## Variants:
##    ADD.W <reg>, <word-value>
##    ADD.D <dreg>, <dword-value>
##
## Adds a value to the specified register.
################################################################################

instruction ADD.W "$r, $m" {
  $GetWord;
  ADD(a,r);
  MSR(ZSCO,ZSCO);
}

instruction ADD.D "$R, $m" {
  $GetDword;
  ADD(a0,r0);
  MSR(Z,Z);
  ADC(a1,r1);
  MSR(ZSCO,_SCO);
}

################################################################################
## ADQ <register>, <value>
##
## Cycles: 4-5
## ZSCO: XXXX
##
## Variants:
##    ADQ.W <reg>, <0..31>
##    ADQ.D <dreg>, <0..31>
##
## Adds a value to the specified register.
################################################################################

instruction ADQ.W "$r, $#5" {
  UL;
  ADD(a,C1);
  MSR(ZSCO,ZSCO);
}

instruction ADQ.D "$R, $#5" {
  UL;
  ADD(a0,C1);
  MSR(Z,Z);
  ADC(a1,C2);
  MSR(ZSCO,_SCO);
}

################################################################################
## ADC <register>, <value>
##
## Cycles: 4+
## ZSCO: XXXX
##
## Variants:
##    ADC.W <reg>, <word-value>
##    ADC.D <dreg>, <dword-value>
##
## Adds a value to the specified register.
################################################################################

instruction ADC.W "$r, $m" {
  $GetWord;
  ADC(a,r);
  MSR(ZSCO,ZSCO);
}

instruction ADC.D "$R, $m" {
  $GetDword;
  ADC(a0,r0);
  MSR(Z,Z);
  ADC(a1,r1);
  MSR(ZSCO,_SCO);
}

################################################################################
## SUB <register>, <value>
##
## Cycles: 4+
## ZSCO: XXXX
##
## Variants:
##    SUB.W <reg>, <word-value>
##    SUB.D <dreg>, <dword-value>
##
## Subtracts a value to the specified register.
################################################################################

instruction SUB.W "$r, $m" {
  $GetWord;
  SUB(a,r);
  MSR(ZSCO,ZSCO);
}

instruction SUB.D "$R, $m" {
  $GetDword;
  SUB(a0,r0);
  MSR(Z,Z);
  SBC(a1,r1);
  MSR(ZSCO,_SCO);
}

################################################################################
## SBQ <register>, <value>
##
## Cycles: 4-5
## ZSCO: XXXX
##
## Variants:
##    SBQ.W <reg>, <0..31>
##    SBQ.D <dreg>, <0..31>
##
## Adds a value to the specified register.
################################################################################

instruction SBQ.W "$r, $#5" {
  UL;
  SUB(a,C1);
  MSR(ZSCO,ZSCO);
}

instruction SBQ.D "$R, $#5" {
  UL;
  SUB(a0,C1);
  MSR(Z,Z);
  SBC(a1,C2);
  MSR(ZSCO,_SCO);
}

################################################################################
## SBC <register>, <value>
##
## Cycles: 4+
## ZSCO: XXXX
##
## Variants:
##    SBC.W <reg>, <word-value>
##    SBC.D <dreg>, <dword-value>
##
## Adds a value to the specified register.
################################################################################

instruction SBC.W "$r, $m" {
  $GetWord;
  SBC(a,r);
  MSR(ZSCO,ZSCO);
}

instruction SBC.D "$R, $m" {
  $GetDword;
  SBC(a0,r0);
  MSR(Z,Z);
  SBC(a1,r1);
  MSR(ZSCO,_SCO);
}

################################################################################
## NOT <register>
##
## Cycles: 5-9
## ZSCO: XX00
##
## Variants:
##    NOT.W <reg>
##    NOT.D <dreg>
##
## Bitwise NOT of the value in the specified register.
################################################################################

instruction NOT.W "$r" {
  UL;
  NOT(a,a); MSR(ZSCO,ZSCO);
}

instruction NOT.D "$R" {
  UL;
  NOT(a0,a0); MSR(Z,Z);
  NOT(a1,a1); MSR(ZSCO,_SCO);
}

################################################################################
## AND <register>, <value>
##
## Cycles: 4+
## ZSCO: XX00
##
## Variants:
##    AND.W <reg>, <word-value>
##    AND.D <dreg>, <dword-value>
##
## Bitwise AND a value to the specified register.
################################################################################

instruction AND.W "$r, $m" {
  $GetWord;
  AND(a,r);
  MSR(ZSCO,ZSCO);
}

instruction AND.D "$R, $m" {
  $GetDword;
  AND(a0,r0);
  MSR(Z,Z);
  AND(a1,r1);
  MSR(ZSCO,_SCO);
}

################################################################################
## OR <register>, <value>
##
## Cycles: 4+
## ZSCO: XX00
##
## Variants:
##    OR.W <reg>, <word-value>
##    OR.D <dreg>, <dword-value>
##
## Bitwise OR a value to the specified register.
################################################################################

instruction OR.W "$r, $m" {
  $GetWord;
  OR(a,r);
  MSR(ZSCO,ZSCO);
}

instruction OR.D "$R, $m" {
  $GetDword;
  OR(a0,r0);
  MSR(Z,Z);
  OR(a1,r1);
  MSR(ZSCO,_SCO);
}

################################################################################
## XOR <register>, <value>
##
## Cycles: 4+
## ZSCO: XX00
##
## Variants:
##    XOR.W <reg>, <word-value>
##    XOR.D <dreg>, <dword-value>
##
## Bitwise XOR a value to the specified register.
################################################################################

instruction XOR.W "$r, $m" {
  $GetWord;
  XOR(a,r);
  MSR(ZSCO,ZSCO);
}

instruction XOR.D "$R, $m" {
  $GetDword;
  XOR(a0,r0);
  MSR(Z,Z);
  XOR(a1,r1);
  MSR(ZSCO,_SCO);
}

################################################################################
## CLRB <register>, <bit-position>
##
## Cycles: 6+
## ZSCO: ----
##
## Variants:
##    CLRB.W <reg>, <word-value>
##    CLRB.D <dreg>, <dword-value>
##
## Clears bit in the specified register.
################################################################################

instruction CLRB.W "$r, $m" {
  $Get16BitMask;
  NOT(r,r);
  AND(a,r);
}

instruction CLRB.D "$R, $m" {
  $Get32BitMask;
  NOT(r0,r0);
  NOT(r1,r1);
  AND(a0,r0);
  AND(a1,r1);
}

################################################################################
## SETB <register>, <bit-position>
##
## Cycles: 5+
## ZSCO: ----
##
## Variants:
##    SETB.W <reg>, <word-value>
##    SETB.D <dreg>, <dword-value>
##
## Sets bit in the specified register.
################################################################################

instruction SETB.W "$r, $m" {
  $Get16BitMask;
  OR(a,r);
}

instruction SETB.D "$R, $m" {
  $Get32BitMask;
  OR(a0,r0);
  OR(a1,r1);
}

################################################################################
## XORB <register>, <bit-position>
##
## Cycles: 5+
## ZSCO: ----
##
## Variants:
##    XORB.W <reg>, <word-value>
##    XORB.D <dreg>, <dword-value>
##
## Toggles bit in the specified register.
################################################################################

instruction XORB.W "$r, $m" {
  $Get16BitMask;
  XOR(a,r);
}

instruction XORB.D "$R, $m" {
  $Get32BitMask;
  XOR(a0,r0);
  XOR(a1,r1);
}

################################################################################
## TSTB <register>, <bit-position>
##
## Cycles: 5+
## ZSCO: X---
##
## Variants:
##    TSTB.W <reg>, <word-value>
##    TSTB.D <dreg>, <dword-value>
##
## Tests a bit in the specified register, setting Z if it is zero.
################################################################################

instruction TSTB.W "$r, $m" {
  $Get16BitMask;
  AND(r,a);
  MSR(Z,Z);
}

instruction TSTB.D "$R, $m" {
  $Get32BitMask;
  AND(r0,a0);
  MSR(Z,Z);
  AND(r1,a1);
  MSR(Z,_);
}

################################################################################
## CLRF <flags>
##
## Cycles: 3
## ZSCO: ????
##
## Clears the specified status flags.
################################################################################

macro ClearFlag {
  code "Z"    { MSC(Z);    MSR(Z,_); }
  code "S"    { MSC(S);    MSR(S,_); }
  code "ZS"   { MSC(ZS);   MSR(ZS,_); }
  code "C"    { MSC(C);    MSR(C,_); }
  code "ZC"   { MSC(ZC);   MSR(ZC,_); }
  code "SC"   { MSC(SC);   MSR(SC,_); }
  code "ZSC"  { MSC(ZSC);  MSR(ZSC,_); }
  code "O"    { MSC(O);    MSR(O,_); }
  code "ZO"   { MSC(ZO);   MSR(ZO,_); }
  code "SO"   { MSC(SO);   MSR(SO,_); }
  code "ZSO"  { MSC(ZSO);  MSR(ZSO,_); }
  code "CO"   { MSC(CO);   MSR(CO,_); }
  code "ZCO"  { MSC(ZCO);  MSR(ZCO,_); }
  code "SCO"  { MSC(SCO);  MSR(SCO,_); }
  code "ZSCO" { MSC(ZSCO); MSR(ZSCO,_); }
}

instruction CLRF "$m" {
  $ClearFlag; UL;
}

################################################################################
## SETF <flags>
##
## Cycles: 3
## ZSCO: ????
##
## Sets the specified status flags.
################################################################################

macro SetFlag {
  code "Z"    { MSS(Z);    MSR(_,Z); }
  code "S"    { MSS(S);    MSR(_,S); }
  code "ZS"   { MSS(ZS);   MSR(_,ZS); }
  code "C"    { MSS(C);    MSR(_,C); }
  code "ZC"   { MSS(ZC);   MSR(_,ZC); }
  code "SC"   { MSS(SC);   MSR(_,SC); }
  code "ZSC"  { MSS(ZSC);  MSR(_,ZSC); }
  code "O"    { MSS(O);    MSR(_,O); }
  code "ZO"   { MSS(ZO);   MSR(_,ZO); }
  code "SO"   { MSS(SO);   MSR(_,SO); }
  code "ZSO"  { MSS(ZSO);  MSR(_,ZSO); }
  code "CO"   { MSS(CO);   MSR(_,CO); }
  code "ZCO"  { MSS(ZCO);  MSR(_,ZCO); }
  code "SCO"  { MSS(SCO);  MSR(_,SCO); }
  code "ZSCO" { MSS(ZSCO); MSR(_,ZSCO); }
}

instruction SETF "$m" {
  $SetFlag; UL;
}

################################################################################
## TST <value>
##
## Cycles: 4+
## ZSCO: XXXX
##
## Variants:
##    TST.W <word-value>
##    TST.D <dword-value>
##
## Tests a value setting flags.
################################################################################

instruction TST.W "$m" {
  $GetWord;
  CMP(C0,r);
  MSR(ZSCO,ZSCO);
}

instruction TST.D "$m" {
  $GetDword;
  CMP(C2,r0);
  MSR(Z,Z);
  SBC(C2,r1);
  MSR(ZSCO,_SCO);
}

################################################################################
## CMP <register> <value>
##
## Cycles: 4+
## ZSCO: XXXX
##
## Variants:
##    CMP.W <reg> <word-value>
##    CMP.D <dreg> <dword-value>
##
## Subtracts <value> from <register> setting flags, but not updating <register>.
################################################################################

instruction CMP.W "$r, $m" {
  $GetWord;
  CMP(a,r);
  MSR(ZSCO,ZSCO);
}

instruction CMP.D "$R, $m" {
  $GetDword;
  CMP(a0,r0);
  MSR(Z,Z);
  MOV(C2,a1);
  SBC(C2,r1);
  MSR(ZSCO,_SCO);
}

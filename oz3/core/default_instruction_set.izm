################################################################################
## Shared macros to fetch word and dword values
################################################################################

# Returns a word value as a register.
#
# Ends fetch phase.
# Modifies register "C2" and returns result in register "r".
macro(bits:5) GetWord:r {
  code:m "$r" {
    UL;
  }
  code:C2 "($r)" {
    UL; LKR(m); ADR(m); LD(C2); UL;
  }
  code:C2 "($r + $v)" {
    LD(C2); UL; ADD(C2,m); LKR(m); ADR(C2); LD(C2); UL;
  }
  code:C2 "(SP)" {
    UL; LK(STACK); ADR(SP); LD(C2); UL;
  }
  code:C2 "(SP + $v)" {
    LD(C2); UL; ADD(C2,SP); LK(STACK); ADR(C2); LD(C2); UL;
  }
  code:C2 "(FP)" {
    UL; LK(STACK); ADR(FP); LD(C2); UL;
  }
  code:C2 "(FP + $v)" {
    LD(C2); UL; ADD(C2,FP); LK(STACK); ADR(C2); LD(C2); UL;
  }
  code:C2 "$v" {
    LD(C2); UL;
  }
  code:C2 "S($v)" {
    LD(C2); UL; LK(STACK); ADR(C2); LD(C2); UL;
  }
  code:C2 "D($v)" {
    LD(C2); UL; LK(DATA); ADR(C2); LD(C2); UL;
  }
  code:C2 "E($v)" {
    LD(C2); UL; LK(EXTRA); ADR(C2); LD(C2); UL;
  }
}

# Returns a dword value as a register.
#
# Ends fetch phase.
# Modifies register "C0" and "C1" and returns result in register "R".
macro(bits:5) GetDword:R {
  code:M "$R" {
    UL;
  }
  code:CD "[$r]" {
    UL; LKR(m); ADR(m); LD(C0); LD(C1); UL;
  }
  code:CD "[$r + $v]" {
    LD(C0); UL; ADD(C0,m); LKR(m); ADR(C0); LD(C0); LD(C1); UL;
  }
  code:CD "[SP]" {
    UL; LK(STACK); ADR(SP); LD(C0); LD(C1); UL;
  }
  code:CD "[SP + $v]" {
    LD(C0); UL; ADD(C0,SP); LK(STACK); ADR(C0); LD(C0); LD(C1); UL;
  }
  code:CD "[FP]" {
    UL; LK(STACK); ADR(FP); LD(C0); LD(C1); UL;
  }
  code:CD "[FP + $v]" {
    LD(C0); UL; ADD(C0,FP); LK(STACK); ADR(C0); LD(C0); LD(C1); UL;
  }
  code:CD "$v" {
    LD(C0); UL;
  }
  code:CD "S[$v]" {
    LD(C0); UL; LK(STACK); ADR(C0); LD(C0); LD(C1); UL;
  }
  code:CD "D[$v]" {
    LD(C0); UL; LK(DATA); ADR(C0); LD(C0); LD(C1); UL;
  }
  code:CD "E[$v]" {
    LD(C0); UL; LK(EXTRA); ADR(C0); LD(C0); LD(C1); UL;
  }
}

# Returns a 16-bit mask for a specified bit position (0-15) otherwise
# returns zero
#
# Ends fetch phase.
# Requires C1=0
# Modifies C0, C2.
macro(bits:5) Get16BitMask:r {
  code:C0 "$r" {
    UL;
    MOV(C2,m);
    MOVI(C0,1);
    CMP(C1,m);
    JC(Z,@done);
  @shift:
    SL(C0);
    JD(C2,@shift);
  @done: MSS(_);
  }

  code:C0 "0"  { UL; MOVI(C0,0x01); }
  code:C0 "1"  { UL; MOVI(C0,0x02); }
  code:C0 "2"  { UL; MOVI(C0,0x04); }
  code:C0 "3"  { UL; MOVI(C0,0x08); }
  code:C0 "4"  { UL; MOVI(C0,0x10); }
  code:C0 "5"  { UL; MOVI(C0,0x20); }
  code:C0 "6"  { UL; MOVI(C0,0x40); }
  code:C0 "7"  {
    UL; MOVI(C0,0x40);
    SL(C0);
  }
  code:C0 "8"  {
    UL; MOVI(C0,0x40);
    SL(C0); SL(C0);
  }
  code:C0 "9"  {
    UL; MOVI(C0,0x40);
    SL(C0); SL(C0); SL(C0);
  }
  code:C0 "10" {
    UL; MOVI(C0,0x40);
    SL(C0); SL(C0); SL(C0); SL(C0);
  }
  code:C0 "11" {
    UL; MOVI(C0,0x40);
    SL(C0); SL(C0); SL(C0); SL(C0); SL(C0);
  }
  code:C0 "12" {
    UL; MOVI(C0,0x40);
    SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0);
  }
  code:C0 "13" {
    UL; MOVI(C0,0x40);
    SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0);
  }
  code:C0 "14" {
    UL; MOVI(C0,0x40);
    SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0);
  }
  code:C0 "15" {
    UL; MOVI(C0,0x40);
    SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0);
  }
}

# Returns a 32-bit mask for a specified bit position (0-31) otherwise
# returns zero
#
# Ends fetch phase.
# Requires: C0=0 and C1=0
# Modifies: C0, C1, C2
macro(bits:6) Get32BitMask:R {
  code:CD "$r" {
    UL;
    MOVI(C2,16);
    CMP(C2,m);
    JC(S,@upper);
    JC(Z,@sixteen);
    MOVI(C0,1);
    CMP(C1,m);
    JC(Z,@done);
    MOV(C2,m);
  @shift_lower:
    SL(C0);
    JD(C2,@shift_lower);
    JP(@done);
  @sixteen:
    MOVI(C1,1);
    JP(@done);
  @upper:
    MOV(C2,m);
    ADDI(C2,-16);
    MOVI(C1,1);
    CMP(C0,C2);
    JC(Z,@done);
  @shift_upper:
    SL(C1);
    JD(C2,@shift_upper);
  @done: MSS(_);
  }

  code:CD "0"  { UL; MOVI(C0,0x0001); }
  code:CD "1"  { UL; MOVI(C0,0x0002); }
  code:CD "2"  { UL; MOVI(C0,0x0004); }
  code:CD "3"  { UL; MOVI(C0,0x0008); }
  code:CD "4"  { UL; MOVI(C0,0x0010); }
  code:CD "5"  { UL; MOVI(C0,0x0020); }
  code:CD "6"  { UL; MOVI(C0,0x0040); }
  code:CD "7"  {
    UL; MOVI(C0,0x0040);
    SL(C0);
  }
  code:CD "8"  {
    UL; MOVI(C0,0x0040);
    SL(C0); SL(C0);
  }
  code:CD "9"  {
    UL; MOVI(C0,0x0040);
    SL(C0); SL(C0); SL(C0);
  }
  code:CD "10" {
    UL; MOVI(C0,0x0040);
    SL(C0); SL(C0); SL(C0); SL(C0);
  }
  code:CD "11" {
    UL; MOVI(C0,0x0040);
    SL(C0); SL(C0); SL(C0); SL(C0); SL(C0);
  }
  code:CD "12" {
    UL; MOVI(C0,0x0040);
    SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0);
  }
  code:CD "13" {
    UL; MOVI(C0,0x0040);
    SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0);
  }
  code:CD "14" {
    UL; MOVI(C0,0x0040);
    SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0);
  }
  code:CD "15" {
    UL; MOVI(C0,0x0040);
    SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0);
  }
  code:CD "16"  { UL; MOVI(C1,0x0001); }
  code:CD "17"  { UL; MOVI(C1,0x0002); }
  code:CD "18"  { UL; MOVI(C1,0x0004); }
  code:CD "19"  { UL; MOVI(C1,0x0008); }
  code:CD "20"  { UL; MOVI(C1,0x0010); }
  code:CD "21"  { UL; MOVI(C1,0x0020); }
  code:CD "22"  { UL; MOVI(C1,0x0040); }
  code:CD "23"  {
    UL; MOVI(C1,0x0040);
    SL(C1);
  }
  code:CD "24"  {
    UL; MOVI(C1,0x0040);
    SL(C1); SL(C1);
  }
  code:CD "25"  {
    UL; MOVI(C1,0x0040);
    SL(C1); SL(C1); SL(C1);
  }
  code:CD "26" {
    UL; MOVI(C1,0x0040);
    SL(C1); SL(C1); SL(C1); SL(C1);
  }
  code:CD "27" {
    UL; MOVI(C1,0x0040);
    SL(C1); SL(C1); SL(C1); SL(C1); SL(C1);
  }
  code:CD "28" {
    UL; MOVI(C1,0x0040);
    SL(C1); SL(C1); SL(C1); SL(C1); SL(C1); SL(C1);
  }
  code:CD "29" {
    UL; MOVI(C1,0x0040);
    SL(C1); SL(C1); SL(C1); SL(C1); SL(C1); SL(C1); SL(C1);
  }
  code:CD "30" {
    UL; MOVI(C1,0x0040);
    SL(C1); SL(C1); SL(C1); SL(C1); SL(C1); SL(C1); SL(C1); SL(C1);
  }
  code:CD "31" {
    UL; MOVI(C1,0x0040);
    SL(C1); SL(C1); SL(C1); SL(C1); SL(C1); SL(C1); SL(C1); SL(C1); SL(C1);
  }
}

################################################################################
## NOP
##
## Cycles: 3
## ZSCO: ----
##
## Minimal instruction that does nothing.
################################################################################

instruction(opcode:0) NOP {
  UL;
}

################################################################################
## HALT
##
## Cycles: 3
## ZSCO: ----
##
## Puts the core into the IDLE state. Interrupts will still be triggered and
## executed, but the core will stay idle until it is reset to a new code
## location.
################################################################################

instruction HALT {
  UL;
  ADDI(IP,-1);  # Reset IP so core stays halted after interrupt
  HALT;         # Put the core into idle state.
}

################################################################################
## WAIT <reg>
##
## Cycles: 3+ ()
## ZSCO: ---X
##
## Puts the core into the WAIT state for at least the number of cycles
## specified. Interrupts may still be executed during the WAIT state, but
## cannot recursively call WAIT themselves.
##
## After a successful WAIT execution (it was not called recursively from within
## an interrupt), the provided register will be update with the number of
## additional cycles taken. This may be longer than the requested time due to
## an interrupt occurring or the core getting locked.
##
## On failure, the O flag is set. Otherwise it is cleared.
################################################################################

instruction WAIT "$r" {
  UL;
  WAIT(a);
}

################################################################################
## MOV <dst> <src>
##
## Cycles: 4+
## ZSCO: ----
##
## Variants:
##    MOV.LW <reg> <word-value>
##    MOV.LD <dreg> <dword-value>
##    MOV.SW <word-address> <reg>
##    MOV.SD <dword-address> <dreg>
##    MOV.S  <sreg> <reg>
##    MOV.S  <reg> <sreg>
##
## Moves (copies) the value from from <src> into <dst>.
################################################################################

macro(bits:5) LoadWord(p) {
  code "$r"         { UL; MOV(p,m); }
  code "($r)"       { UL; LKR(m); ADR(m); LD(p); UL; }
  code "($r + $v)"  { LD(C2); UL; ADD(C2,m); LKR(m); ADR(C2); LD(p); UL; }
  code "(SP)"       { UL; LK(STACK); ADR(SP); LD(p); UL; }
  code "(SP + $v)"  { LD(C2); UL; ADD(C2,SP); LK(STACK); ADR(C2); LD(p); UL; }
  code "(FP)"       { UL; LK(STACK); ADR(FP); LD(p); UL; }
  code "(FP + $v)"  { LD(C2); UL; ADD(C2,FP); LK(STACK); ADR(C2); LD(p); UL; }
  code "$v"         { LD(p); UL; }
  code "S($v)"      { LD(C2); UL; LK(STACK); ADR(C2); LD(p); UL; }
  code "D($v)"      { LD(C2); UL; LK(DATA); ADR(C2); LD(p); UL; }
  code "E($v)"      { LD(C2); UL; LK(EXTRA); ADR(C2); LD(p); UL; }
}

instruction MOV.LW "$r, $m" {
  $LoadWord(a);
}

macro(bits:5) LoadDword(P) {
  code "$R" {
    UL; MOV(p0,m0); MOV(p1,m1);
  }
  code "[$r]" {
    UL; LKR(m); ADR(m); LD(p0); LD(p1); UL;
  }
  code "[$r + $v]" {
    LD(C2); UL; ADD(C2,m); LKR(m); ADR(C2); LD(p0); LD(p1); UL;
  }
  code "[SP]" {
    UL; LK(STACK); ADR(SP); LD(p0); LD(p1); UL;
  }
  code "[SP + $v]" {
    LD(C2); UL; ADD(C2,SP); LK(STACK); ADR(C2); LD(p0); LD(p1); UL;
  }
  code "[FP]" {
    UL; LK(STACK); ADR(FP); LD(p0); LD(p1); UL;
  }
  code "[FP + $v]" {
    LD(C2); UL; ADD(C2,FP); LK(STACK); ADR(C2); LD(p0); LD(p1); UL;
  }
  code "$V" {
    LD(p0); LD(p1); UL;
  }
  code "S[$v]" {
    LD(C2); UL; LK(STACK); ADR(C2); LD(p0); LD(p1); UL;
  }
  code "D[$v]" {
    LD(C2); UL; LK(DATA); ADR(C2); LD(p0); LD(p1); UL;
  }
  code "E[$v]" {
    LD(C2); UL; LK(EXTRA); ADR(C2); LD(p0); LD(p1); UL;
  }
}

instruction MOV.LD "$R, $m" {
  $LoadDword(A);
}

macro(bits:5) StoreWord(p) {
  code "($r)"       { UL; LKR(m); ADR(m); ST(p); UL; }
  code "($r + $v)"  { LD(C2); UL; ADD(C2,m); LKR(m); ADR(C2); ST(p); UL; }
  code "(SP)"       { UL; LK(STACK); ADR(SP); ST(p); UL; }
  code "(SP + $v)"  { LD(C2); UL; ADD(C2,SP); LK(STACK); ADR(C2); ST(p); UL; }
  code "(FP)"       { UL; LK(STACK); ADR(FP); ST(p); UL; }
  code "(FP + $v)"  { LD(C2); UL; ADD(C2,FP); LK(STACK); ADR(C2); ST(p); UL; }
  code "S($v)"      { LD(C2); UL; LK(STACK); ADR(C2); ST(p); UL; }
  code "D($v)"      { LD(C2); UL; LK(DATA); ADR(C2); ST(p); UL; }
  code "E($v)"      { LD(C2); UL; LK(EXTRA); ADR(C2); ST(p); UL; }
}

instruction MOV.SW "$m, $r" {
  $StoreWord(b);
}

macro(bits:5) StoreDword(P) {
  code "[$r]" {
    UL; LKR(m); ADR(m); ST(p0); ST(p1); UL;
  }
  code "[$r + $v]" {
    LD(C2); UL; ADD(C2,m); LKR(m); ADR(C2); ST(p0); ST(p1); UL;
  }
  code "[SP]" {
    UL; LK(STACK); ADR(SP); ST(p0); ST(p1); UL;
  }
  code "[SP + $v]" {
    LD(C2); UL; ADD(C2,SP); LK(STACK); ADR(C2); ST(p0); ST(p1); UL;
  }
  code "[FP]" {
    UL; LK(STACK); ADR(FP); ST(p0); ST(p1); UL;
  }
  code "[FP + $v]" {
    LD(C2); UL; ADD(C2,FP); LK(STACK); ADR(C2); ST(p0); ST(p1); UL;
  }
  code "S[$v]" {
    LD(C2); UL; LK(STACK); ADR(C2); ST(p0); ST(p1); UL;
  }
  code "D[$v]" {
    LD(C2); UL; LK(DATA); ADR(C2); ST(p0); ST(p1); UL;
  }
  code "E[$v]" {
    LD(C2); UL; LK(EXTRA); ADR(C2); ST(p0); ST(p1); UL;
  }
}

instruction MOV.SD "$m, $R" {
  $StoreDword(B);
}

macro MoveSReg {
  code "$r, BC" { UL; MOV(m,BC); }
  code "$r, BS" { UL; MOV(m,BS); }
  code "$r, BD" { UL; MOV(m,BD); }
  code "$r, BE" { UL; MOV(m,BE); }
  code "$r, FP" { UL; MOV(m,FP); }
  code "$r, SP" { UL; MOV(m,SP); }
  code "BC, $r" { UL; MOV(BC,m); }
  code "BS, $r" { UL; MOV(BS,m); }
  code "BD, $r" { UL; MOV(BD,m); }
  code "BE, $r" { UL; MOV(BE,m); }
  code "FP, $r" { UL; MOV(FP,m); }
  code "SP, $r" { UL; MOV(SP,m); }
  code "BC, $v" { LD(C0); UL; MOV(BC,C0); }
  code "BS, $v" { LD(C0); UL; MOV(BS,C0); }
  code "BD, $v" { LD(C0); UL; MOV(BD,C0); }
  code "BE, $v" { LD(C0); UL; MOV(BE,C0); }
  code "FP, $v" { LD(C0); UL; MOV(FP,C0); }
  code "SP, $v" { LD(C0); UL; MOV(SP,C0); }
}

instruction MOV.S "$m" {
  $MoveSReg;
}

################################################################################
## MVQ <dst> <value>
##
## Cycles: 4-5
## ZSCO: ----
##
## Variants:
##    MVQ.LW <reg> <0..31>
##    MVQ.LD <dreg> <0..31>
##
## Moves the immediate value in the range [0,31] to the specified register.
################################################################################

instruction MVQ.LW "$r, $#5" {
  UL; MOV(a,C1);
}

instruction MVQ.LD "$R, $#5" {
  UL; MOV(a0,C1); MOVI(a1,0);
}

################################################################################
## PUSH <src>
##
## Cycles: 5+
## ZSCO: ----
##
## Variants:
##    PUSH.W <word-value>
##    PUSH.D <dword-value>
##
## Pushes the value onto the stack, updating SP.
################################################################################

instruction PUSH.W "$m" {
  $GetWord;
  LK(STACK); ADR(SP); STP(C2); LAD(SP); UL;
}

instruction PUSH.D "$m" {
  $GetDword;
  LK(STACK); ADR(SP); STP(C1); STP(C0); LAD(SP); UL;
}

################################################################################
## POP <dst>
##
## Cycles: 5+
## ZSCO: ----
##
## Variants:
##    POP.W <reg>
##    POP.W <word-address>
##    POP.D <dreg>
##    POP.D <dword-address>
##
## Pops the value from the stack, updating SP. The destination address is
## determined *after* the the value is popped, which affects addresses using an
## offset from SP.
################################################################################

macro PopWord {
  code "$r" {
    UL;
    LK(STACK); ADR(SP); LD(m); LAD(SP); UL;
  }
  code "($r)" {
    UL;
    LK(STACK); ADR(SP); LD(C2); LAD(SP); UL;
    LKR(m); ADR(m); ST(C2); UL;
  }
  code "($r + $v)" {
    LD(C0); UL;
    LK(STACK); ADR(SP); LD(C2); LAD(SP); UL;
    ADD(C0,m); LKR(m); ADR(C0); ST(C2); UL;
  }
  code "(SP)" {
    UL;
    LK(STACK);
      ADR(SP); LD(C2); LAD(SP);
      ST(C2);
    UL;
  }
  code "(SP + $v)" {
    LD(C0); UL;
    LK(STACK);
      ADR(SP); LD(C2); LAD(SP);
      ADD(C0,SP); ADR(C0); ST(C2);
    UL;
  }
  code "(FP)" {
    UL;
    LK(STACK);
      ADR(SP); LD(C2); LAD(SP);
      ADR(FP); ST(C2);
    UL;
  }
  code "(FP + $v)" {
    LD(C0); UL;
    LK(STACK);
      ADR(SP); LD(C2); LAD(SP);
      ADD(C0,FP); ADR(C0); ST(C2);
    UL;
  }
  code "S($v)" {
    LD(C0); UL;
    LK(STACK);
      ADR(SP); LD(C2); LAD(SP);
      ADR(C0); ST(C2);
    UL;
  }
  code "D($v)" {
    LD(C0); UL;
    LK(STACK); ADR(SP); LD(C2); LAD(SP); UL;
    LK(DATA); ADR(C0); ST(C2); UL;
  }
  code "E($v)" {
    LD(C0); UL;
    LK(STACK); ADR(SP); LD(C2); LAD(SP); UL;
    LK(EXTRA); ADR(C0); ST(C2); UL;
  }
}

instruction POP.W "$m" {
  $PopWord;
}

macro PopDword {
  code "$R" {
    UL;
    LK(STACK); ADR(SP); LD(m0); LD(m1); LAD(SP); UL;
  }
  code "[$r]" {
    UL;
    LK(STACK); ADR(SP); LD(C0); LD(C1); LAD(SP); UL;
    LKR(m); ADR(m); ST(C0); ST(C1); UL;
  }
  code "[$r + $v]" {
    LD(C2); UL;
    LK(STACK); ADR(SP); LD(C0); LD(C1); LAD(SP); UL;
    ADD(C2,m); LKR(m); ADR(C2); ST(C0); ST(C1); UL;
  }
  code "[SP]" {
    UL;
    LK(STACK);
      ADR(SP); LD(C0); LD(C1); LAD(SP);
      ST(C0); ST(C1);
    UL;
  }
  code "[SP + $v]" {
    LD(C2); UL;
    LK(STACK);
      ADR(SP); LD(C0); LD(C1); LAD(SP);
      ADD(C2,SP); ADR(C2); ST(C0); ST(C1);
    UL;
  }
  code "[FP]" {
    UL;
    LK(STACK);
      ADR(SP); LD(C0); LD(C1); LAD(SP);
      ADR(FP); ST(C0); ST(C1);
    UL;
  }
  code "[FP + $v]" {
    LD(C2); UL;
    LK(STACK);
      ADR(SP); LD(C0); LD(C1); LAD(SP);
      ADD(C2,FP); ADR(C2); ST(C0); ST(C1);
    UL;
  }
  code "S[$v]" {
    LD(C2); UL;
    LK(STACK);
      ADR(SP); LD(C0); LD(C1); LAD(SP);
      ADR(C2); ST(C0); ST(C1);
    UL;
  }
  code "D[$v]" {
    LD(C2); UL;
    LK(STACK); ADR(SP); LD(C0); LD(C1); LAD(SP); UL;
    LK(DATA); ADR(C2); ST(C0); ST(C1); UL;
  }
  code "E[$v]" {
    LD(C2); UL;
    LK(STACK); ADR(SP); LD(C0); LD(C1); LAD(SP); UL;
    LK(EXTRA); ADR(C2); ST(C0); ST(C1); UL;
  }
}

instruction POP.D "$m" {
  $PopDword;
}

################################################################################
## SWP <a> <b>
##
## Cycles: 6+
## ZSCO: ----
##
## Variants:
##    SWP.W <reg> <reg>
##    SWP.W <reg> <word-address>
##    SWP.D <dreg> <dreg>
##    SWP.D <dreg> <dword-address>
##
## Swaps the contents of the specified register <a> with a register or memory
## address value <b>
################################################################################

macro SwapWord(p) {
  code "$r" {
    UL;
    MOV(C0,p); MOV(p,m); MOV(m,C0);
  }
  code "($r)" {
    UL;
    MOV(C0,p); LKR(m); ADR(m); LD(p); STP(C0); UL;
  }
  code "($r + $v)" {
    LD(C2); UL; ADD(C2,m);
    MOV(C0,p); LKR(m); ADR(C2); LD(p); STP(C0); UL;
  }
  code "(SP)" {
    UL;
    MOV(C0,p); LK(STACK); ADR(SP); LD(p); STP(C0); UL;
  }
  code "(SP + $v)" {
    LD(C2); UL; ADD(C2,SP);
    MOV(C0,p); LK(STACK); ADR(C2); LD(p); STP(C0); UL;
  }
  code "(FP)" {
    UL;
    MOV(C0,p); LK(STACK); ADR(FP); LD(p); STP(C0); UL;
  }
  code "(FP + $v)" {
    LD(C2); UL; ADD(C2,FP);
    MOV(C0,p); LK(STACK); ADR(C2); LD(p); STP(C0); UL;
  }
  code "S($v)" {
    LD(C2); UL;
    MOV(C0,p); LK(STACK); ADR(C2); LD(p); STP(C0); UL;
  }
  code "D($v)" {
    LD(C2); UL;
    MOV(C0,p); LK(DATA); ADR(C2); LD(p); STP(C0); UL;
  }
  code "E($v)" {
    LD(C2); UL;
    MOV(C0,p); LK(EXTRA); ADR(C2); LD(p); STP(C0); UL;
  }
}

instruction SWP.W "$r, $m" {
  $SwapWord(a);
}

macro SwapDword(P) {
  code "$R" {
    UL;
    MOV(C0,p0); MOV(p0,m0); MOV(m0,C0);
    MOV(C1,p1); MOV(p1,m1); MOV(m1,C1);
  }
  code "($r)" {
    UL;
    MOV(C0,p0); MOV(C1,p1);
    LKR(m); ADR(m); LD(p0); LD(p1); STP(C1); STP(C0); UL;
  }
  code "($r + $v)" {
    LD(C2); UL; ADD(C2,m);
    MOV(C0,p0); MOV(C1,p1);
    LKR(m); ADR(C2); LD(p0); LD(p1); STP(C1); STP(C0); UL;
  }
  code "(SP)" {
    UL;
    MOV(C0,p0); MOV(C1,p1);
    LK(STACK); ADR(SP); LD(p0); LD(p1); STP(C1); STP(C0); UL;
  }
  code "(SP + $v)" {
    LD(C2); UL; ADD(C2,SP);
    MOV(C0,p0); MOV(C1,p1);
    LK(STACK); ADR(C2); LD(p0); LD(p1); STP(C1); STP(C0); UL;
  }
  code "(FP)" {
    UL;
    MOV(C0,p0); MOV(C1,p1);
    LK(STACK); ADR(FP); LD(p0); LD(p1); STP(C1); STP(C0); UL;
  }
  code "(FP + $v)" {
    LD(C2); UL; ADD(C2,FP);
    MOV(C0,p0); MOV(C1,p1);
    LK(STACK); ADR(C2); LD(p0); LD(p1); STP(C1); STP(C0); UL;
  }
  code "S($v)" {
    LD(C2); UL;
    MOV(C0,p0); MOV(C1,p1);
    LK(STACK); ADR(C2); LD(p0); LD(p1); STP(C1); STP(C0); UL;
  }
  code "D($v)" {
    LD(C2); UL;
    MOV(C0,p0); MOV(C1,p1);
    LK(DATA); ADR(C2); LD(p0); LD(p1); STP(C1); STP(C0); UL;
  }
  code "E($v)" {
    LD(C2); UL;
    MOV(C0,p0); MOV(C1,p1);
    LK(EXTRA); ADR(C2); LD(p0); LD(p1); STP(C1); STP(C0); UL;
  }
}

instruction SWP.D "$R, $m" {
  $SwapDword(A);
}


################################################################################
## NEG <register>
##
## Cycles: 5-9
## ZSCO: XX00
##
## Variants:
##    NEG.W <reg>
##    NEG.D <dreg>
##
## Negates the value in the specified register.
################################################################################

instruction NEG.W "$r" {
  UL;
  # The contract is to always clear the CO flags, which SUB won't do, so we need
  # to clear them explicitly before returning the status
  SUB(C0,a); MSC(CO); MSR(ZSCO,ZSCO);

  # Copy result back to the register
  MOV(a,C0);
}

instruction NEG.D "$R" {
  UL;

  # Proactively set zero bit here based on low-order result.
  SUB(C0,a0); MSR(Z,Z);

  # Clear the zero bit (but don't set it) based on high-order result.
  SBC(C1,a1); MSC(CO); MSR(ZSCO,_SCO);

  # Copy result back to the register
  MOV(a0,C0); MOV(a1,C1);
}

################################################################################
## ADD <register>, <value>
##
## Cycles: 4+
## ZSCO: XXXX
##
## Variants:
##    ADD.W <reg>, <word-value>
##    ADD.D <dreg>, <dword-value>
##    ADD.S SP, <word-value>
##
## Adds a value to the specified register.
################################################################################

instruction ADD.W "$r, $m" {
  $GetWord;
  ADD(a,r);
  MSR(ZSCO,ZSCO);
}

instruction ADD.D "$R, $m" {
  $GetDword;
  ADD(a0,r0);
  MSR(Z,Z);
  ADC(a1,r1);
  MSR(ZSCO,_SCO);
}

instruction ADD.S "SP, $m" {
  $GetWord;
  ADD(SP,r);
  MSR(ZSCO,ZSCO);
}

################################################################################
## ADQ <register>, <value>
##
## Cycles: 4-5
## ZSCO: XXXX
##
## Variants:
##    ADQ.W <reg>, <0..31>
##    ADQ.D <dreg>, <0..31>
##    ADQ.S SP, <0..31>
##
## Adds an immediate value to the specified register.
################################################################################

instruction ADQ.W "$r, $#5" {
  UL;
  ADD(a,C1);
  MSR(ZSCO,ZSCO);
}

instruction ADQ.D "$R, $#5" {
  UL;
  ADD(a0,C1);
  MSR(Z,Z);
  ADC(a1,C2);
  MSR(ZSCO,_SCO);
}

instruction ADQ.S "SP, $#5" {
  UL;
  ADD(SP,C1);
  MSR(ZSCO,ZSCO);
}

################################################################################
## ADC <register>, <value>
##
## Cycles: 4+
## ZSCO: XXXX
##
## Variants:
##    ADC.W <reg>, <word-value>
##    ADC.D <dreg>, <dword-value>
##
## Adds a value to the specified register.
################################################################################

instruction ADC.W "$r, $m" {
  $GetWord;
  ADC(a,r);
  MSR(ZSCO,ZSCO);
}

instruction ADC.D "$R, $m" {
  $GetDword;
  ADC(a0,r0);
  MSR(Z,Z);
  ADC(a1,r1);
  MSR(ZSCO,_SCO);
}

################################################################################
## SUB <register>, <value>
##
## Cycles: 4+
## ZSCO: XXXX
##
## Variants:
##    SUB.W <reg>, <word-value>
##    SUB.D <dreg>, <dword-value>
##    SUB.S SP, <word-value>
##
## Subtracts a value to the specified register.
################################################################################

instruction SUB.W "$r, $m" {
  $GetWord;
  SUB(a,r);
  MSR(ZSCO,ZSCO);
}

instruction SUB.D "$R, $m" {
  $GetDword;
  SUB(a0,r0);
  MSR(Z,Z);
  SBC(a1,r1);
  MSR(ZSCO,_SCO);
}

instruction SUB.S "SP, $m" {
  $GetWord;
  SUB(SP,r);
  MSR(ZSCO,ZSCO);
}

################################################################################
## SBQ <register>, <value>
##
## Cycles: 4-5
## ZSCO: XXXX
##
## Variants:
##    SBQ.W <reg>, <0..31>
##    SBQ.D <dreg>, <0..31>
##    SBQ.S SP, <0..31>
##
## Subtracts an immediate value to the specified register.
################################################################################

instruction SBQ.W "$r, $#5" {
  UL;
  SUB(a,C1);
  MSR(ZSCO,ZSCO);
}

instruction SBQ.D "$R, $#5" {
  UL;
  SUB(a0,C1);
  MSR(Z,Z);
  SBC(a1,C2);
  MSR(ZSCO,_SCO);
}

instruction SBQ.S "SP, $#5" {
  UL;
  SUB(SP,C1);
  MSR(ZSCO,ZSCO);
}

################################################################################
## SBC <register>, <value>
##
## Cycles: 4+
## ZSCO: XXXX
##
## Variants:
##    SBC.W <reg>, <word-value>
##    SBC.D <dreg>, <dword-value>
##
## Adds a value to the specified register.
################################################################################

instruction SBC.W "$r, $m" {
  $GetWord;
  SBC(a,r);
  MSR(ZSCO,ZSCO);
}

instruction SBC.D "$R, $m" {
  $GetDword;
  SBC(a0,r0);
  MSR(Z,Z);
  SBC(a1,r1);
  MSR(ZSCO,_SCO);
}

################################################################################
## NOT <register>
##
## Cycles: 5-9
## ZSCO: XX00
##
## Variants:
##    NOT.W <reg>
##    NOT.D <dreg>
##
## Bitwise NOT of the value in the specified register.
################################################################################

instruction NOT.W "$r" {
  UL;
  NOT(a,a); MSR(ZSCO,ZSCO);
}

instruction NOT.D "$R" {
  UL;
  NOT(a0,a0); MSR(Z,Z);
  NOT(a1,a1); MSR(ZSCO,_SCO);
}

################################################################################
## AND <register>, <value>
##
## Cycles: 4+
## ZSCO: XX00
##
## Variants:
##    AND.W <reg>, <word-value>
##    AND.D <dreg>, <dword-value>
##
## Bitwise AND a value to the specified register.
################################################################################

instruction AND.W "$r, $m" {
  $GetWord;
  AND(a,r);
  MSR(ZSCO,ZSCO);
}

instruction AND.D "$R, $m" {
  $GetDword;
  AND(a0,r0);
  MSR(Z,Z);
  AND(a1,r1);
  MSR(ZSCO,_SCO);
}

################################################################################
## OR <register>, <value>
##
## Cycles: 4+
## ZSCO: XX00
##
## Variants:
##    OR.W <reg>, <word-value>
##    OR.D <dreg>, <dword-value>
##
## Bitwise OR a value to the specified register.
################################################################################

instruction OR.W "$r, $m" {
  $GetWord;
  OR(a,r);
  MSR(ZSCO,ZSCO);
}

instruction OR.D "$R, $m" {
  $GetDword;
  OR(a0,r0);
  MSR(Z,Z);
  OR(a1,r1);
  MSR(ZSCO,_SCO);
}

################################################################################
## XOR <register>, <value>
##
## Cycles: 4+
## ZSCO: XX00
##
## Variants:
##    XOR.W <reg>, <word-value>
##    XOR.D <dreg>, <dword-value>
##
## Bitwise XOR a value to the specified register.
################################################################################

instruction XOR.W "$r, $m" {
  $GetWord;
  XOR(a,r);
  MSR(ZSCO,ZSCO);
}

instruction XOR.D "$R, $m" {
  $GetDword;
  XOR(a0,r0);
  MSR(Z,Z);
  XOR(a1,r1);
  MSR(ZSCO,_SCO);
}

################################################################################
## CLRB <register>, <bit-position>
##
## Cycles: 6+
## ZSCO: ----
##
## Variants:
##    CLRB.W <reg>, <word-value>
##    CLRB.D <dreg>, <dword-value>
##
## Clears bit in the specified register.
################################################################################

instruction CLRB.W "$r, $m" {
  $Get16BitMask;
  NOT(r,r);
  AND(a,r);
}

instruction CLRB.D "$R, $m" {
  $Get32BitMask;
  NOT(r0,r0);
  NOT(r1,r1);
  AND(a0,r0);
  AND(a1,r1);
}

################################################################################
## SETB <register>, <bit-position>
##
## Cycles: 5+
## ZSCO: ----
##
## Variants:
##    SETB.W <reg>, <word-value>
##    SETB.D <dreg>, <dword-value>
##
## Sets bit in the specified register.
################################################################################

instruction SETB.W "$r, $m" {
  $Get16BitMask;
  OR(a,r);
}

instruction SETB.D "$R, $m" {
  $Get32BitMask;
  OR(a0,r0);
  OR(a1,r1);
}

################################################################################
## XORB <register>, <bit-position>
##
## Cycles: 5+
## ZSCO: ----
##
## Variants:
##    XORB.W <reg>, <word-value>
##    XORB.D <dreg>, <dword-value>
##
## Toggles bit in the specified register.
################################################################################

instruction XORB.W "$r, $m" {
  $Get16BitMask;
  XOR(a,r);
}

instruction XORB.D "$R, $m" {
  $Get32BitMask;
  XOR(a0,r0);
  XOR(a1,r1);
}

################################################################################
## TSTB <register>, <bit-position>
##
## Cycles: 5+
## ZSCO: X---
##
## Variants:
##    TSTB.W <reg>, <word-value>
##    TSTB.D <dreg>, <dword-value>
##
## Tests a bit in the specified register, setting Z if it is zero.
################################################################################

instruction TSTB.W "$r, $m" {
  $Get16BitMask;
  AND(r,a);
  MSR(Z,Z);
}

instruction TSTB.D "$R, $m" {
  $Get32BitMask;
  AND(r0,a0);
  MSR(Z,Z);
  AND(r1,a1);
  MSR(Z,_);
}

################################################################################
## CLRF <flags>
##
## Cycles: 3
## ZSCO: ????
##
## Clears the specified status flags.
################################################################################

instruction CLRF "$#4" {
  MSC(a); MSR(a,_); UL;
}

################################################################################
## SETF <flags>
##
## Cycles: 3
## ZSCO: ????
##
## Sets the specified status flags.
################################################################################

instruction SETF "$#4" {
  MSS(a); MSR(_,a); UL;
}

################################################################################
## NOTF <flags>
##
## Cycles: 3
## ZSCO: ????
##
## Performs a bitwise NOT to the specified status flags.
################################################################################

instruction NOTF "$#4" {
  MSX(a); MSR(a,a); UL;
}

################################################################################
## TST <value>
##
## Cycles: 4+
## ZSCO: XXXX
##
## Variants:
##    TST.W <word-value>
##    TST.D <dword-value>
##
## Tests a value setting flags.
################################################################################

instruction TST.W "$m" {
  $GetWord;
  CMP(C0,r);
  MSR(ZSCO,ZSCO);
}

instruction TST.D "$m" {
  $GetDword;
  CMP(C2,r0);
  MSR(Z,Z);
  SBC(C2,r1);
  MSR(ZSCO,_SCO);
}

################################################################################
## CMP <register> <value>
##
## Cycles: 4+
## ZSCO: XXXX
##
## Variants:
##    CMP.W <reg> <word-value>
##    CMP.D <dreg> <dword-value>
##
## Subtracts <value> from <register> setting flags, but not updating <register>.
################################################################################

instruction CMP.W "$r, $m" {
  $GetWord;
  CMP(a,r);
  MSR(ZSCO,ZSCO);
}

instruction CMP.D "$R, $m" {
  $GetDword;
  CMP(a0,r0);
  MSR(Z,Z);
  MOV(C2,a1);
  SBC(C2,r1);
  MSR(ZSCO,_SCO);
}

################################################################################
## JP <address>
##
## Cycles: 4+
## ZSCO: ----
##
## Sets IP to the specified address.
################################################################################

instruction JP "$m" {
  $GetWord;
  MOV(IP,r);
}

################################################################################
## JPR <relative-address>
##
## Cycles: 4+
## ZSCO: ----
##
## Adds the specified relative address to IP.
################################################################################

instruction JPR "$m" {
  $GetWord;
  ADD(IP,r);
}

################################################################################
## JC <condition> <address>
##
## Cycles: 3+
## ZSCO: ----
##
## Sets IP to the specified address if the specified condition is true.
################################################################################

instruction JC "$#3, $m" {
  $GetWord;
  JC(a,@jump);
  END;
@jump:
  MOV(IP,r);
}

################################################################################
## JCR <condition> <relative-address>
##
## Cycles: 3+
## ZSCO: ----
##
## Adds the specified relative address to IP if the specified condition is true.
################################################################################

instruction JCR "$#3, $m" {
  $GetWord;
  JC(a,@jump);
  END;
@jump:
  ADD(IP,r);
}

################################################################################
## CALL <address>
##
## Cycles: 6+
## ZSCO: ----
##
## Pushes IP onto the stack and sets IP to the specified address.
################################################################################

instruction CALL "$m" {
  $GetWord;
  LK(STACK); ADR(SP); STP(IP); UL;
  MOV(IP,r);
}

################################################################################
## CALLR <relative-address>
##
## Cycles: 6+
## ZSCO: ----
##
## Pushes IP onto the stack and adds the specified relative address to IP.
################################################################################

instruction CALLR "$m" {
  $GetWord;
  LK(STACK); ADR(SP); STP(IP); UL;
  ADD(IP,r);
}

################################################################################
## FBGN
##
## Cycles: 6
## ZSCO: ----
##
## Pushes FP onto the stack and sets it to SP.
################################################################################

instruction FBGN {
  UL;
  LK(STACK); ADR(SP); STP(FP); LAD(SP); UL;
  MOV(FP,SP);
}

################################################################################
## FEND
##
## Cycles: 6
## ZSCO: ----
##
## Restores SP from FP and removes FP from the stack
################################################################################

instruction FEND {
  UL;
  MOV(SP,FP);
  LK(STACK); ADR(SP); LD(FP); LAD(SP); UL;
}

################################################################################
## RET
## RET <size>
##
## Cycles: 5-6
## ZSCO: ----
##
## Variants:
##   RET
##   RET.A <size>
##
## Pops 0-31 words from the stack, then pops IP from the stack.
################################################################################

instruction RET {
  UL;
  LK(STACK); ADR(SP); LD(IP); LAD(SP); UL;
}

instruction RET.A "$#5" {
  UL;
  ADD(SP,C0);
  LK(STACK); ADR(SP); LD(IP); LAD(SP); UL;
}

################################################################################
## RETC <condition>
## RETC <condition> <size>
##
## Cycles: 3-7
## ZSCO: ----
##
## Variants:
##   RETC   <condition>
##   RETC.A <condition> <size>
##
## If the specified condition is true, optionally pops 0-31 words from the
## stack, then pops IP from the stack.
################################################################################

instruction RETC "$#3" {
  UL;
  JC(a,@return);
  END;
@return:
  LK(STACK); ADR(SP); LD(IP); LAD(SP); UL;
}

instruction RETC.A "$#3, $#5" {
  UL;
  JC(a,@return);
  END;
@return:
  ADD(SP,C1);
  LK(STACK); ADR(SP); LD(IP); LAD(SP); UL;
}

################################################################################
## IRT
## IRT <size>
##
## Cycles: 7-8
## ZSCO: ----
##
## Variants:
##   IRT
##   IRT.A <size>
##
## Pops 0-31 words from the stack, then pops ST and IP from the stack.
################################################################################

instruction IRT {
  UL;
  LK(STACK); ADR(SP); LD(ST); LD(IP); LAD(SP); UL;
  MSM(ZSCOI,ST); MSR(ZSCOI,ZSCOI);
}

instruction IRT.A "$#5" {
  UL;
  ADD(SP,C0);
  LK(STACK); ADR(SP); LD(ST); LD(IP); LAD(SP); UL;
  MSM(ZSCOI,ST); MSR(ZSCOI,ZSCOI);
}

################################################################################
## IRTC <condition>
## IRTC <condition> <size>
##
## Cycles: 3-9
## ZSCO: ----
##
## Variants:
##   IRTC   <condition>
##   IRTC.A <condition> <size>
##
## If the specified condition is true, optionally pops 0-31 words from the
## stack, then pops ST and IP from the stack.
################################################################################

instruction IRTC "$#3" {
  UL;
  JC(a,@return);
  END;
@return:
  LK(STACK); ADR(SP); LD(ST); LD(IP); LAD(SP); UL;
  MSM(ZSCOI,ST); MSR(ZSCOI,ZSCOI);
}

instruction IRTC.A "$#3, $#5" {
  UL;
  JC(a,@return);
  END;
@return:
  ADD(SP,C1);
  LK(STACK); ADR(SP); LD(ST); LD(IP); LAD(SP); UL;
  MSM(ZSCOI,ST); MSR(ZSCOI,ZSCOI);
}

################################################################################
## EI
##
## Cycles: 3
## ZSCO: ----
##
## Enables interrupts.
################################################################################

instruction EI {
  UL;
  MSS(I);
  MSR(_,I);
}

################################################################################
## DI
##
## Cycles: 3
## ZSCO: ----
##
## Disables interrupts.
################################################################################

instruction DI {
  UL;
  MSC(I);
  MSR(I,_);
}

################################################################################
## GETI <interrupt> <register>
##
## Cycles: 4+
## ZSCO: ----
##
## Retrieves the address of the specified interrupt and assigns to a register.
################################################################################

instruction GETI "$m, $r" {
  $GetWord;
  ILD(r,b);
}

################################################################################
## SETI <interrupt> <register>
##
## Cycles: 4+
## ZSCO: ----
##
## Sets the address of the specified interrupt from a register.
################################################################################

instruction SETI "$m, $r" {
  $GetWord;
  IST(r,b);
}

################################################################################
## INT <interrupt>
##
## Cycles: 4+
## ZSCO: ----
##
## Triggers the specified interrupt.
################################################################################

instruction INT "$m" {
  $GetWord;
  INT(r);
}

################################################################################
## IN <port> <dst>
##
## Cycles: 4+
## ZSCO: -X--
##
## Variants:
##    IN.RW <reg>    <reg>
##    IN.RW <reg>    <word-address>
##    IN.IW <0..255> <reg>
##    IN.IW <0..255> <word-address>
##    IN.RD <reg>    <dreg>
##    IN.RD <reg>    <dword-address>
##    IN.ID <0..255> <dreg>
##    IN.ID <0..255> <dword-address>
##
## Unconditionally reads from the specified port and writes to the specified
## register or memory address. "S" flag is set if a new word was read, otherwise
## it is cleared.
################################################################################

macro(bits:5) ReadPortWord(p) {
  code "$r" {
    UL;
    PLK(p); PLD(S,m); MSR(S,S); PUL;
  }
  code "($r)" {
    UL;
    PLK(p); PLD(S,C0); MSR(S,S); PUL;
    LKR(m); ADR(m); ST(C0); UL;
  }
  code "($r + $v)" {
    LD(C2); UL; ADD(C2,m);
    PLK(p); PLD(S,C0); MSR(S,S); PUL;
    LKR(m); ADR(C2); ST(C0); UL;
  }
  code "(SP)" {
    UL;
    PLK(p); PLD(S,C0); MSR(S,S); PUL;
    LK(STACK); ADR(SP); ST(C0); UL;
  }
  code "(SP + $v)" {
    LD(C2); UL; ADD(C2,SP);
    PLK(p); PLD(S,C0); MSR(S,S); PUL;
    LK(STACK); ADR(C2); ST(C0); UL;
  }
  code "(FP)" {
    UL;
    PLK(p); PLD(S,C0); MSR(S,S); PUL;
    LK(STACK); ADR(FP); ST(C0); UL;
  }
  code "(FP + $v)" {
    LD(C2); UL; ADD(C2,FP);
    PLK(p); PLD(S,C0); MSR(S,S); PUL;
    LK(STACK); ADR(C2); ST(C0); UL;
  }
  code "S($v)" {
    LD(C2); UL;
    PLK(p); PLD(S,C0); MSR(S,S); PUL;
    LK(STACK); ADR(C2); ST(C0); UL;
  }
  code "D($v)" {
    LD(C2); UL;
    PLK(p); PLD(S,C0); MSR(S,S); PUL;
    LK(DATA); ADR(C2); ST(C0); UL;
  }
  code "E($v)" {
    LD(C2); UL;
    PLK(p); PLD(S,C0); MSR(S,S); PUL;
    LK(EXTRA); ADR(C2); ST(C0); UL;
  }
}

instruction IN.RW "$r, $m" {
  $ReadPortWord(a);
}

instruction IN.IW "$v, $m" {
  LD(MB);
  $ReadPortWord(MB);
}

macro(bits:5) ReadPortDword(p) {
  code "$R" {
    UL;
    PLK(p); PLD(A,m0); PLD(S,m1); MSR(S,S); PUL;
  }
  code "[$r]" {
    UL;
    PLK(p); PLD(A,C0); PLD(S,C1); MSR(S,S); PUL;
    LKR(m); ADR(m); ST(C0); ST(C1); UL;
  }
  code "[$r + $v]" {
    LD(C2); UL; ADD(C2,m);
    PLK(p); PLD(A,C0); PLD(S,C1); MSR(S,S); PUL;
    LKR(m); ADR(C2); ST(C0); ST(C1); UL;
  }
  code "[SP]" {
    UL;
    PLK(p); PLD(A,C0); PLD(S,C1); MSR(S,S); PUL;
    LK(STACK); ADR(SP); ST(C0); ST(C1); UL;
  }
  code "[SP + $v]" {
    LD(C2); UL; ADD(C2,SP);
    PLK(p); PLD(A,C0); PLD(S,C1); MSR(S,S); PUL;
    LK(STACK); ADR(C2); ST(C0); ST(C1); UL;
  }
  code "[FP]" {
    UL;
    PLK(p); PLD(A,C0); PLD(S,C1); MSR(S,S); PUL;
    LK(STACK); ADR(FP); ST(C0); ST(C1); UL;
  }
  code "[FP + $v]" {
    LD(C2); UL; ADD(C2,FP);
    PLK(p); PLD(A,C0); PLD(S,C1); MSR(S,S); PUL;
    LK(STACK); ADR(C2); ST(C0); ST(C1); UL;
  }
  code "S[$v]" {
    LD(C2); UL;
    PLK(p); PLD(A,C0); PLD(S,C1); MSR(S,S); PUL;
    LK(STACK); ADR(C2); ST(C0); ST(C1); UL;
  }
  code "D[$v]" {
    LD(C2); UL;
    PLK(p); PLD(A,C0); PLD(S,C1); MSR(S,S); PUL;
    LK(DATA); ADR(C2); ST(C0); ST(C1); UL;
  }
  code "E[$v]" {
    LD(C2); UL;
    PLK(p); PLD(A,C0); PLD(S,C1); MSR(S,S); PUL;
    LK(EXTRA); ADR(C2); ST(C0); ST(C1); UL;
  }
}

instruction IN.RD "$r, $m" {
  $ReadPortDword(a);
}

instruction IN.ID "$v, $m" {
  LD(MB);
  $ReadPortDword(MB);
}

################################################################################
## INS <port> <dst>
##
## Cycles: 4+
## ZSCO: -X--
##
## Variants:
##    INS.RW <reg>    <reg>
##    INS.RW <reg>    <word-address>
##    INS.IW <0..255> <reg>
##    INS.IW <0..255> <word-address>
##    INS.RD <reg>    <dreg>
##    INS.RD <reg>    <dword-address>
##    INS.ID <0..255> <dreg>
##    INS.ID <0..255> <dword-address>
##
## Reads from the specified port if the port status is set and writes to the
## specified register or memory address. "S" flag is set if a word was read,
## otherwise it is cleared.
################################################################################

macro(bits:5) ReadPortWordIfReady(p) {
  code "$r" {
    UL;
    PLK(p); PLD(TS,m); MSR(S,S); PUL;
  }
  code "($r)" {
    UL;
    PLK(p); PLD(TS,C0); MSR(S,S); PUL;
    JC(S,@ready);
    END;
  @ready:
    LKR(m); ADR(m); ST(C0); UL;
  }
  code "($r + $v)" {
    LD(C2); UL;
    PLK(p); PLD(TS,C0); MSR(S,S); PUL;
    JC(S,@ready);
    END;
  @ready:
    ADD(C2,m);
    LKR(m); ADR(C2); ST(C0); UL;
  }
  code "(SP)" {
    UL;
    PLK(p); PLD(TS,C0); MSR(S,S); PUL;
    JC(S,@ready);
    END;
  @ready:
    LK(STACK); ADR(SP); ST(C0); UL;
  }
  code "(SP + $v)" {
    LD(C2); UL;
    PLK(p); PLD(TS,C0); MSR(S,S); PUL;
    JC(S,@ready);
    END;
  @ready:
    ADD(C2,SP);
    LK(STACK); ADR(C2); ST(C0); UL;
  }
  code "(FP)" {
    UL;
    PLK(p); PLD(TS,C0); MSR(S,S); PUL;
    JC(S,@ready);
    END;
  @ready:
    LK(STACK); ADR(FP); ST(C0); UL;
  }
  code "(FP + $v)" {
    LD(C2); UL;
    PLK(p); PLD(TS,C0); MSR(S,S); PUL;
    JC(S,@ready);
    END;
  @ready:
    ADD(C2,FP);
    LK(STACK); ADR(C2); ST(C0); UL;
  }
  code "S($v)" {
    LD(C2); UL;
    PLK(p); PLD(TS,C0); MSR(S,S); PUL;
    JC(S,@ready);
    END;
  @ready:
    LK(STACK); ADR(C2); ST(C0); UL;
  }
  code "D($v)" {
    LD(C2); UL;
    PLK(p); PLD(TS,C0); MSR(S,S); PUL;
    JC(S,@ready);
    END;
  @ready:
    LK(DATA); ADR(C2); ST(C0); UL;
  }
  code "E($v)" {
    LD(C2); UL;
    PLK(p); PLD(TS,C0); MSR(S,S); PUL;
    JC(S,@ready);
    END;
  @ready:
    LK(EXTRA); ADR(C2); ST(C0); UL;
  }
}

instruction INS.RW "$r, $m" {
  $ReadPortWordIfReady(a);
}

instruction INS.IW "$v, $m" {
  LD(MB);
  $ReadPortWordIfReady(MB);
}

macro(bits:5) ReadPortDwordIfReady(p) {
  code "$R" {
    UL;
    PLK(p); PLD(TA,m0); PLD(TS,m1); MSR(S,S); PUL;
  }
  code "[$r]" {
    UL;
    PLK(p); PLD(TA,C0); PLD(TS,C1); MSR(S,S); PUL;
    JC(S,@ready);
    END;
  @ready:
    LKR(m); ADR(m); ST(C0); ST(C1); UL;
  }
  code "[$r + $v]" {
    LD(C2); UL;
    PLK(p); PLD(TA,C0); PLD(TS,C1); MSR(S,S); PUL;
    JC(S,@ready);
    END;
  @ready:
    ADD(C2,m);
    LKR(m); ADR(C2); ST(C0); ST(C1); UL;
  }
  code "[SP]" {
    UL;
    PLK(p); PLD(TA,C0); PLD(TS,C1); MSR(S,S); PUL;
    JC(S,@ready);
    END;
  @ready:
    LK(STACK); ADR(SP); ST(C0); ST(C1); UL;
  }
  code "[SP + $v]" {
    LD(C2); UL;
    PLK(p); PLD(TA,C0); PLD(TS,C1); MSR(S,S); PUL;
    JC(S,@ready);
    END;
  @ready:
    ADD(C2,SP);
    LK(STACK); ADR(C2); ST(C0); ST(C1); UL;
  }
  code "[FP]" {
    UL;
    PLK(p); PLD(TA,C0); PLD(TS,C1); MSR(S,S); PUL;
    JC(S,@ready);
    END;
  @ready:
    LK(STACK); ADR(FP); ST(C0); ST(C1); UL;
  }
  code "[FP + $v]" {
    LD(C2); UL;
    PLK(p); PLD(TA,C0); PLD(TS,C1); MSR(S,S); PUL;
    JC(S,@ready);
    END;
  @ready:
    ADD(C2,FP);
    LK(STACK); ADR(C2); ST(C0); ST(C1); UL;
  }
  code "S[$v]" {
    LD(C2); UL;
    PLK(p); PLD(TA,C0); PLD(TS,C1); MSR(S,S); PUL;
    JC(S,@ready);
    END;
  @ready:
    LK(STACK); ADR(C2); ST(C0); ST(C1); UL;
  }
  code "D[$v]" {
    LD(C2); UL;
    PLK(p); PLD(TA,C0); PLD(TS,C1); MSR(S,S); PUL;
    JC(S,@ready);
    END;
  @ready:
    LK(DATA); ADR(C2); ST(C0); ST(C1); UL;
  }
  code "E[$v]" {
    LD(C2); UL;
    PLK(p); PLD(TA,C0); PLD(TS,C1); MSR(S,S); PUL;
    JC(S,@ready);
    END;
  @ready:
    LK(EXTRA); ADR(C2); ST(C0); ST(C1); UL;
  }
}

instruction INS.RD "$r, $m" {
  $ReadPortDwordIfReady(a);
}

instruction INS.ID "$v, $m" {
  LD(MB);
  $ReadPortDwordIfReady(MB);
}

################################################################################
## INR <port> <address>
##
## Cycles: 5+
## ZSCO: -X--
##
## Variants:
##    INR.RW <reg>    <word-address>
##    INR.IW <0..255> <word-address>
##    INR.RD <reg>    <dword-address>
##    INR.ID <0..255> <dword-address>
##
## Reads up to R7 words from the specified port as long as port status is set
## before each read and writes sequentially starting at the specified memory
## address. R7 is set to the number of words *not* read. The "S" flag is set
## if all words/dwords were read (R7 == 0), otherwise it is cleared.
################################################################################

macro(bits:5) ReadPortWordRepeat(p) {
  code "($r)" {
    UL;
    MSS(S); MSR(_,S);
    CMP(C0,R7);
    JC(Z,@done);
    MOV(C2,m);
  @read:
    PLK(p); PLD(TS,C0); MSR(S,S); PUL;
    JC(NS,@done);
    LKR(m); ADR(C2); ST(C0); LAD(C2); UL;
    JD(R7,@read);
  @done:
    END;
  }
  code "($r + $v)" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(C0,R7);
    JC(Z,@done);
    ADD(C2,m);
  @read:
    PLK(p); PLD(TS,C0); MSR(S,S); PUL;
    JC(NS,@done);
    LKR(m); ADR(C2); ST(C0); LAD(C2); UL;
    JD(R7,@read);
  @done:
    END;
  }
  code "(SP)" {
    UL;
    MSS(S); MSR(_,S);
    CMP(C0,R7);
    JC(Z,@done);
    MOV(C2,SP);
  @read:
    PLK(p); PLD(TS,C0); MSR(S,S); PUL;
    JC(NS,@done);
    LK(STACK); ADR(C2); ST(C0); LAD(C2); UL;
    JD(R7,@read);
  @done:
    END;
  }
  code "(SP + $v)" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(C0,R7);
    JC(Z,@done);
    ADD(C2,SP);
  @read:
    PLK(p); PLD(TS,C0); MSR(S,S); PUL;
    JC(NS,@done);
    LK(STACK); ADR(C2); ST(C0); LAD(C2); UL;
    JD(R7,@read);
  @done:
    END;
  }
  code "(FP)" {
    UL;
    MSS(S); MSR(_,S);
    CMP(C0,R7);
    JC(Z,@done);
    MOV(C2,FP);
  @read:
    PLK(p); PLD(TS,C0); MSR(S,S); PUL;
    JC(NS,@done);
    LK(STACK); ADR(C2); ST(C0); LAD(C2); UL;
    JD(R7,@read);
  @done:
    END;
  }
  code "(FP + $v)" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(C0,R7);
    JC(Z,@done);
    ADD(C2,FP);
  @read:
    PLK(p); PLD(TS,C0); MSR(S,S); PUL;
    JC(NS,@done);
    LK(STACK); ADR(C2); ST(C0); LAD(C2); UL;
    JD(R7,@read);
  @done:
    END;
  }
  code "S($v)" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(C0,R7);
    JC(Z,@done);
  @read:
    PLK(p); PLD(TS,C0); MSR(S,S); PUL;
    JC(NS,@done);
    LK(STACK); ADR(C2); ST(C0); LAD(C2); UL;
    JD(R7,@read);
  @done:
    END;
  }
  code "D($v)" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(C0,R7);
    JC(Z,@done);
  @read:
    PLK(p); PLD(TS,C0); MSR(S,S); PUL;
    JC(NS,@done);
    LK(DATA); ADR(C2); ST(C0); LAD(C2); UL;
    JD(R7,@read);
  @done:
    END;
  }
  code "E($v)" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(C0,R7);
    JC(Z,@done);
  @read:
    PLK(p); PLD(TS,C0); MSR(S,S); PUL;
    JC(NS,@done);
    LK(EXTRA); ADR(C2); ST(C0); LAD(C2); UL;
    JD(R7,@read);
  @done:
    END;
  }
}

instruction INR.RW "$r, $m" {
  $ReadPortWordRepeat(a);
}

instruction INR.IW "$v, $m" {
  LD(MB);
  $ReadPortWordRepeat(MB);
}

macro(bits:5) ReadPortDwordRepeat(p) {
  code "[$r]" {
    UL;
    MSS(S); MSR(_,S);
    CMP(C0,R7);
    JC(Z,@done);
    MOV(C2,m);
  @read:
    PLK(p); PLD(TA,C0); PLD(TS,C1); MSR(S,S); PUL;
    JC(NS,@done);
    LKR(m); ADR(C2); ST(C0); ST(C1); LAD(C2); UL;
    JD(R7,@read);
  @done:
    END;
  }
  code "[$r + $v]" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(C0,R7);
    JC(Z,@done);
    ADD(C2,m);
  @read:
    PLK(p); PLD(TA,C0); PLD(TS,C1); MSR(S,S); PUL;
    JC(NS,@done);
    LKR(m); ADR(C2); ST(C0); ST(C1); LAD(C2); UL;
    JD(R7,@read);
  @done:
    END;
  }
  code "[SP]" {
    UL;
    MSS(S); MSR(_,S);
    CMP(C0,R7);
    JC(Z,@done);
    MOV(C2,SP);
  @read:
    PLK(p); PLD(TA,C0); PLD(TS,C1); MSR(S,S); PUL;
    JC(NS,@done);
    LK(STACK); ADR(C2); ST(C0); ST(C1); LAD(C2); UL;
    JD(R7,@read);
  @done:
    END;
  }
  code "[SP + $v]" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(C0,R7);
    JC(Z,@done);
    ADD(C2,SP);
  @read:
    PLK(p); PLD(TA,C0); PLD(TS,C1); MSR(S,S); PUL;
    JC(NS,@done);
    LK(STACK); ADR(C2); ST(C0); ST(C1); LAD(C2); UL;
    JD(R7,@read);
  @done:
    END;
  }
  code "[FP]" {
    UL;
    MSS(S); MSR(_,S);
    CMP(C0,R7);
    JC(Z,@done);
    MOV(C2,FP);
  @read:
    PLK(p); PLD(TA,C0); PLD(TS,C1); MSR(S,S); PUL;
    JC(NS,@done);
    LK(STACK); ADR(C2); ST(C0); ST(C1); LAD(C2); UL;
    JD(R7,@read);
  @done:
    END;
  }
  code "[FP + $v]" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(C0,R7);
    JC(Z,@done);
    ADD(C2,FP);
  @read:
    PLK(p); PLD(TA,C0); PLD(TS,C1); MSR(S,S); PUL;
    JC(NS,@done);
    LK(STACK); ADR(C2); ST(C0); ST(C1); LAD(C2); UL;
    JD(R7,@read);
  @done:
    END;
  }
  code "S[$v]" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(C0,R7);
    JC(Z,@done);
  @read:
    PLK(p); PLD(TA,C0); PLD(TS,C1); MSR(S,S); PUL;
    JC(NS,@done);
    LK(STACK); ADR(C2); ST(C0); ST(C1); LAD(C2); UL;
    JD(R7,@read);
  @done:
    END;
  }
  code "D[$v]" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(C0,R7);
    JC(Z,@done);
  @read:
    PLK(p); PLD(TA,C0); PLD(TS,C1); MSR(S,S); PUL;
    JC(NS,@done);
    LK(DATA); ADR(C2); ST(C0); ST(C1); LAD(C2); UL;
    JD(R7,@read);
  @done:
    END;
  }
  code "E[$v]" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(C0,R7);
    JC(Z,@done);
  @read:
    PLK(p); PLD(TA,C0); PLD(TS,C1); MSR(S,S); PUL;
    JC(NS,@done);
    LK(EXTRA); ADR(C2); ST(C0); ST(C1); LAD(C2); UL;
    JD(R7,@read);
  @done:
    END;
  }
}

instruction INR.RD "$r, $m" {
  $ReadPortDwordRepeat(a);
}

instruction INR.ID "$v, $m" {
  LD(MB);
  $ReadPortDwordRepeat(MB);
}

################################################################################
## OUT <port> <register>
##
## Cycles: 4+
## ZSCO: -1--
##
## Variants:
##    OUT.RW <reg>    <word-value>
##    OUT.IW <0..255> <word-value>
##    OUT.RD <reg>    <dword-value>
##    OUT.ID <0..255> <dword-value>
##
## Unconditionally writes the specified value to the specified port.
################################################################################

macro(bits:5) WritePortWord(p) {
  code "$r" {
    UL;
    PLK(p); PST(S,m); PUL;
    MSS(S); MSR(_,S);
  }
  code "($r)" {
    UL;
    LKR(m); ADR(m); LD(C0); UL;
    PLK(p); PST(S,C0); PUL;
    MSS(S); MSR(_,S);
  }
  code "($r + $v)" {
    LD(C2); UL; ADD(C2,m);
    LKR(m); ADR(C2); LD(C0); UL;
    PLK(p); PST(S,C0); PUL;
  }
  code "(SP)" {
    UL;
    LK(STACK); ADR(SP); LD(C0); UL;
    PLK(p); PST(S,C0); PUL;
    MSS(S); MSR(_,S);
  }
  code "(SP + $v)" {
    LD(C2); UL; ADD(C2,SP);
    LK(STACK); ADR(C2); LD(C0); UL;
    PLK(p); PST(S,C0); PUL;
    MSS(S); MSR(_,S);
  }
  code "(FP)" {
    UL;
    LK(STACK); ADR(FP); LD(C0); UL;
    PLK(p); PST(S,C0); PUL;
    MSS(S); MSR(_,S);
  }
  code "(FP + $v)" {
    LD(C2); UL; ADD(C2,FP);
    LK(STACK); ADR(C2); LD(C0); UL;
    PLK(p); PST(S,C0); PUL;
    MSS(S); MSR(_,S);
  }
  code "$v" {
    LD(C0); UL;
    PLK(p); PST(S,C0); PUL;
    MSS(S); MSR(_,S);
  }
  code "S($v)" {
    LD(C2); UL;
    LK(STACK); ADR(C2); LD(C0); UL;
    PLK(p); PST(S,C0); PUL;
    MSS(S); MSR(_,S);
  }
  code "D($v)" {
    LD(C2); UL;
    LK(DATA); ADR(C2); LD(C0); UL;
    PLK(p); PST(S,C0); PUL;
    MSS(S); MSR(_,S);
  }
  code "E($v)" {
    LD(C2); UL;
    LK(EXTRA); ADR(C2); LD(C0); UL;
    PLK(p); PST(S,C0); PUL;
    MSS(S); MSR(_,S);
  }
}

instruction OUT.RW "$r, $m" {
  $WritePortWord(a);
}

instruction OUT.IW "$v, $m" {
  LD(MB);
  $WritePortWord(MB);
}

macro(bits:5) WritePortDword(p) {
  code "$R" {
    UL;
    PLK(p); PST(A,m0); PST(S,m1); PUL;
  }
  code "[$r]" {
    UL;
    LKR(m); ADR(m); LD(C0); LD(C1); UL;
    PLK(p); PST(A,C0); PST(S,C1); PUL;
    MSS(S); MSR(_,S);
  }
  code "[$r + $v]" {
    LD(C2); UL; ADD(C2,m);
    LKR(m); ADR(C2); LD(C0); LD(C1); UL;
    PLK(p); PST(A,C0); PST(S,C1); PUL;
    MSS(S); MSR(_,S);
  }
  code "[SP]" {
    UL;
    LK(STACK); ADR(SP); LD(C0); LD(C1); UL;
    PLK(p); PST(A,C0); PST(S,C1); PUL;
    MSS(S); MSR(_,S);
  }
  code "[SP + $v]" {
    LD(C2); UL; ADD(C2,SP);
    LK(STACK); ADR(C2); LD(C0); LD(C1); UL;
    PLK(p); PST(A,C0); PST(S,C1); PUL;
    MSS(S); MSR(_,S);
  }
  code "[FP]" {
    UL;
    LK(STACK); ADR(FP); LD(C0); LD(C1); UL;
    PLK(p); PST(A,C0); PST(S,C1); PUL;
    MSS(S); MSR(_,S);
  }
  code "[FP + $v]" {
    LD(C2); UL; ADD(C2,FP);
    LK(STACK); ADR(C2); LD(C0); LD(C1); UL;
    PLK(p); PST(A,C0); PST(S,C1); PUL;
    MSS(S); MSR(_,S);
  }
  code "$V" {
    LD(C0); LD(C1); UL;
    PLK(p); PST(A,C0); PST(S,C1); PUL;
    MSS(S); MSR(_,S);
  }
  code "S[$v]" {
    LD(C2); UL;
    LK(STACK); ADR(C2); LD(C0); LD(C1); UL;
    PLK(p); PST(A,C0); PST(S,C1); PUL;
    MSS(S); MSR(_,S);
  }
  code "D[$v]" {
    LD(C2); UL;
    LK(DATA); ADR(C2); LD(C0); LD(C1); UL;
    PLK(p); PST(A,C0); PST(S,C1); PUL;
    MSS(S); MSR(_,S);
  }
  code "E[$v]" {
    LD(C2); UL;
    LK(EXTRA); ADR(C2); LD(C0); LD(C1); UL;
    PLK(p); PST(A,C0); PST(S,C1); PUL;
    MSS(S); MSR(_,S);
  }
}

instruction OUT.RD "$r, $m" {
  $WritePortDword(a);
}

instruction OUT.ID "$v, $m" {
  LD(MB);
  $WritePortDword(MB);
}

################################################################################
## OUTS <port> <register>
##
## Cycles: 4+
## ZSCO: -X--
##
## Variants:
##    OUTS.RW <reg>    <word-value>
##    OUTS.IW <0..255> <word-value>
##    OUTS.RD <reg>    <dword-value>
##    OUTS.ID <0..255> <dword-value>
##
## Writes the specified value to the specified port if the port status is not
## set. Sets the "S" flag if a value was written.
################################################################################

macro(bits:5) WritePortWordIfReady(p) {
  code "$r" {
    UL;
    PLK(p); PST(TS,m); PUL;
    MSX(S); MSR(S,S);
  }
  code "($r)" {
    UL;
    LKR(m); ADR(m); LD(C0); UL;
    PLK(p); PST(TS,C0); PUL;
    MSX(S); MSR(S,S);
  }
  code "($r + $v)" {
    LD(C2); UL; ADD(C2,m);
    LKR(m); ADR(C2); LD(C0); UL;
    PLK(p); PST(TS,C0); PUL;
    MSX(S); MSR(S,S);
  }
  code "(SP)" {
    UL;
    LK(STACK); ADR(SP); LD(C0); UL;
    PLK(p); PST(TS,C0); PUL;
    MSX(S); MSR(S,S);
  }
  code "(SP + $v)" {
    LD(C2); UL; ADD(C2,SP);
    LK(STACK); ADR(C2); LD(C0); UL;
    PLK(p); PST(TS,C0); PUL;
    MSX(S); MSR(S,S);
  }
  code "(FP)" {
    UL;
    LK(STACK); ADR(FP); LD(C0); UL;
    PLK(p); PST(TS,C0); PUL;
    MSX(S); MSR(S,S);
  }
  code "(FP + $v)" {
    LD(C2); UL; ADD(C2,FP);
    LK(STACK); ADR(C2); LD(C0); UL;
    PLK(p); PST(TS,C0); PUL;
    MSX(S); MSR(S,S);
  }
  code "$v" {
    LD(C0); UL;
    PLK(p); PST(TS,C0); PUL;
    MSX(S); MSR(S,S);
  }
  code "S($v)" {
    LD(C2); UL;
    LK(STACK); ADR(C2); LD(C0); UL;
    PLK(p); PST(TS,C0); PUL;
    MSX(S); MSR(S,S);
  }
  code "D($v)" {
    LD(C2); UL;
    LK(DATA); ADR(C2); LD(C0); UL;
    PLK(p); PST(TS,C0); PUL;
    MSX(S); MSR(S,S);
  }
  code "E($v)" {
    LD(C2); UL;
    LK(EXTRA); ADR(C2); LD(C0); UL;
    PLK(p); PST(TS,C0); PUL;
    MSX(S); MSR(S,S);
  }
}

instruction OUTS.RW "$r, $m" {
  $WritePortWordIfReady(a);
}

instruction OUTS.IW "$v, $m" {
  LD(MB);
  $WritePortWordIfReady(MB);
}

macro(bits:5) WritePortDwordIfReady(p) {
  code "$R" {
    UL;
    PLK(p); PST(A,m0); PST(S,m1); PUL;
    MSX(S); MSR(S,S);
  }
  code "[$r]" {
    UL;
    LKR(m); ADR(m); LD(C0); LD(C1); UL;
    PLK(p); PST(TA,C0); PST(TS,C1); PUL;
    MSX(S); MSR(S,S);
  }
  code "[$r + $v]" {
    LD(C2); UL; ADD(C2,m);
    LKR(m); ADR(C2); LD(C0); LD(C1); UL;
    PLK(p); PST(TA,C0); PST(TS,C1); PUL;
    MSX(S); MSR(S,S);
  }
  code "[SP]" {
    UL;
    LK(STACK); ADR(SP); LD(C0); LD(C1); UL;
    PLK(p); PST(TA,C0); PST(TS,C1); PUL;
    MSX(S); MSR(S,S);
  }
  code "[SP + $v]" {
    LD(C2); UL; ADD(C2,SP);
    LK(STACK); ADR(C2); LD(C0); LD(C1); UL;
    PLK(p); PST(TA,C0); PST(TS,C1); PUL;
    MSX(S); MSR(S,S);
  }
  code "[FP]" {
    UL;
    LK(STACK); ADR(FP); LD(C0); LD(C1); UL;
    PLK(p); PST(TA,C0); PST(TS,C1); PUL;
    MSX(S); MSR(S,S);
  }
  code "[FP + $v]" {
    LD(C2); UL; ADD(C2,FP);
    LK(STACK); ADR(C2); LD(C0); LD(C1); UL;
    PLK(p); PST(TA,C0); PST(TS,C1); PUL;
    MSX(S); MSR(S,S);
  }
  code "$V" {
    LD(C0); LD(C1); UL;
    PLK(p); PST(TA,C0); PST(TS,C1); PUL;
    MSX(S); MSR(S,S);
  }
  code "S[$v]" {
    LD(C2); UL;
    LK(STACK); ADR(C2); LD(C0); LD(C1); UL;
    PLK(p); PST(TA,C0); PST(TS,C1); PUL;
    MSX(S); MSR(S,S);
  }
  code "D[$v]" {
    LD(C2); UL;
    LK(DATA); ADR(C2); LD(C0); LD(C1); UL;
    PLK(p); PST(TA,C0); PST(TS,C1); PUL;
    MSX(S); MSR(S,S);
  }
  code "E[$v]" {
    LD(C2); UL;
    LK(EXTRA); ADR(C2); LD(C0); LD(C1); UL;
    PLK(p); PST(TA,C0); PST(TS,C1); PUL;
    MSX(S); MSR(S,S);
  }
}

instruction OUTS.RD "$r, $m" {
  $WritePortDwordIfReady(a);
}

instruction OUTS.ID "$v, $m" {
  LD(MB);
  $WritePortDwordIfReady(MB);
}

################################################################################
## OUTR <port> <register>
##
## Cycles: 4+
## ZSCO: -X--
##
## Variants:
##    OUTR.RW <reg>    <word-address>
##    OUTR.IW <0..255> <word-address>
##    OUTR.RD <reg>    <dword-address>
##    OUTR.ID <0..255> <dword-address>
##
## Writes up to R7 values to the specified port while the port status is not
## set. R7 holds the number of values not written. Sets the "S" flag if all
## values were was written (R7 is zero).
################################################################################

macro(bits:5) WritePortWordRepeat(p) {
  code "($r)" {
    UL;
    MSS(S); MSR(_,S);
    CMP(C0,R7);
    JC(Z,@done);
    MOV(C2,m);
  @write:
    LKR(m); ADR(C2); LD(C0); LAD(C2); UL;
    PLK(p); PST(TS,C0); PUL;
    MSX(S); MSR(S,S);
    JD(R7, @write);
  @done:
    END;
  }
  code "($r + $v)" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(C0,R7);
    JC(Z,@done);
    ADD(C2,m);
  @write:
    LKR(m); ADR(C2); LD(C0); LAD(C2); UL;
    PLK(p); PST(TS,C0); PUL;
    MSX(S); MSR(S,S);
    JD(R7, @write);
  @done:
    END;
  }
  code "(SP)" {
    UL;
    MSS(S); MSR(_,S);
    CMP(C0,R7);
    JC(Z,@done);
    MOV(C2,SP);
  @write:
    LK(STACK); ADR(SP); LD(C0); LAD(C2); UL;
    PLK(p); PST(TS,C0); PUL;
    MSX(S); MSR(S,S);
    JD(R7, @write);
  @done:
    END;
  }
  code "(SP + $v)" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(C0,R7);
    JC(Z,@done);
    ADD(C2,SP);
  @write:
    LK(STACK); ADR(C2); LD(C0); LAD(C2); UL;
    PLK(p); PST(TS,C0); PUL;
    MSX(S); MSR(S,S);
    JD(R7, @write);
  @done:
    END;
  }
  code "(FP)" {
    UL;
    MSS(S); MSR(_,S);
    CMP(C0,R7);
    JC(Z,@done);
    MOV(C2,FP);
  @write:
    LK(STACK); ADR(C2); LD(C0); LAD(C2); UL;
    PLK(p); PST(TS,C0); PUL;
    MSX(S); MSR(S,S);
    JD(R7, @write);
  @done:
    END;
  }
  code "(FP + $v)" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(C0,R7);
    JC(Z,@done);
    ADD(C2,FP);
  @write:
    LK(STACK); ADR(C2); LD(C0); LAD(C2); UL;
    PLK(p); PST(TS,C0); PUL;
    MSX(S); MSR(S,S);
    JD(R7, @write);
  @done:
    END;
  }
  code "S($v)" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(C0,R7);
    JC(Z,@done);
  @write:
    LK(STACK); ADR(C2); LD(C0); LAD(C2); UL;
    PLK(p); PST(TS,C0); PUL;
    MSX(S); MSR(S,S);
    JD(R7, @write);
  @done:
    END;
  }
  code "D($v)" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(C0,R7);
    JC(Z,@done);
  @write:
    LK(DATA); ADR(C2); LD(C0); LAD(C2); UL;
    PLK(p); PST(TS,C0); PUL;
    MSX(S); MSR(S,S);
    JD(R7, @write);
  @done:
    END;
  }
  code "E($v)" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(C0,R7);
    JC(Z,@done);
  @write:
    LK(EXTRA); ADR(C2); LD(C0); LAD(C2); UL;
    PLK(p); PST(TS,C0); PUL;
    MSX(S); MSR(S,S);
    JD(R7, @write);
  @done:
    END;
  }
}

instruction OUTR.RW "$r, $m" {
  $WritePortWordRepeat(a);
}

instruction OUTR.IW "$v, $m" {
  LD(MB);
  $WritePortWordRepeat(MB);
}

macro(bits:5) WritePortDwordRepeat(p) {
  code "[$r]" {
    UL;
    MSS(S); MSR(_,S);
    CMP(C0,R7);
    JC(Z,@done);
    MOV(C2,m);
  @write:
    LKR(m); ADR(C2); LD(C0); LD(C1); LAD(C2); UL;
    PLK(p); PST(TA,C0); PST(TS,C1); PUL;
    MSX(S); MSR(S,S);
    JD(R7, @write);
  @done:
    END;
  }
  code "[$r + $v]" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(C0,R7);
    JC(Z,@done);
    ADD(C2,m);
  @write:
    LKR(m); ADR(C2); LD(C0); LD(C1); LAD(C2); UL;
    PLK(p); PST(TA,C0); PST(TS,C1); PUL;
    MSX(S); MSR(S,S);
    JD(R7, @write);
  @done:
    END;
  }
  code "[SP]" {
    UL;
    MSS(S); MSR(_,S);
    CMP(C0,R7);
    JC(Z,@done);
    MOV(C2,SP);
  @write:
    LK(STACK); ADR(SP); LD(C0); LD(C1); LAD(C2); UL;
    PLK(p); PST(TA,C0); PST(TS,C1); PUL;
    MSX(S); MSR(S,S);
    JD(R7, @write);
  @done:
    END;
  }
  code "[SP + $v]" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(C0,R7);
    JC(Z,@done);
    ADD(C2,SP);
  @write:
    LK(STACK); ADR(C2); LD(C0); LD(C1); LAD(C2); UL;
    PLK(p); PST(TA,C0); PST(TS,C1); PUL;
    MSX(S); MSR(S,S);
    JD(R7, @write);
  @done:
    END;
  }
  code "[FP]" {
    UL;
    MSS(S); MSR(_,S);
    CMP(C0,R7);
    JC(Z,@done);
    MOV(C2,FP);
  @write:
    LK(STACK); ADR(C2); LD(C0); LD(C1); LAD(C2); UL;
    PLK(p); PST(TA,C0); PST(TS,C1); PUL;
    MSX(S); MSR(S,S);
    JD(R7, @write);
  @done:
    END;
  }
  code "[FP + $v]" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(C0,R7);
    JC(Z,@done);
    ADD(C2,FP);
  @write:
    LK(STACK); ADR(C2); LD(C0); LD(C1); LAD(C2); UL;
    PLK(p); PST(TA,C0); PST(TS,C1); PUL;
    MSX(S); MSR(S,S);
    JD(R7, @write);
  @done:
    END;
  }
  code "S[$v]" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(C0,R7);
    JC(Z,@done);
  @write:
    LK(STACK); ADR(C2); LD(C0); LD(C1); LAD(C2); UL;
    PLK(p); PST(TA,C0); PST(TS,C1); PUL;
    MSX(S); MSR(S,S);
    JD(R7, @write);
  @done:
    END;
  }
  code "D[$v]" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(C0,R7);
    JC(Z,@done);
  @write:
    LK(DATA); ADR(C2); LD(C0); LD(C1); LAD(C2); UL;
    PLK(p); PST(TA,C0); PST(TS,C1); PUL;
    MSX(S); MSR(S,S);
    JD(R7, @write);
  @done:
    END;
  }
  code "E[$v]" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(C0,R7);
    JC(Z,@done);
  @write:
    LK(EXTRA); ADR(C2); LD(C0); LD(C1); LAD(C2); UL;
    PLK(p); PST(TA,C0); PST(TS,C1); PUL;
    MSX(S); MSR(S,S);
    JD(R7, @write);
  @done:
    END;
  }
}

instruction OUTR.RD "$r, $m" {
  $WritePortDwordRepeat(a);
}

instruction OUTR.ID "$v, $m" {
  LD(MB);
  $WritePortDwordRepeat(MB);
}


################################################################################
## Shared macros to fetch word and dword values
################################################################################

# Returns a word value as a register.
#
# Ends fetch phase.
# Modifies register "C2" and returns result in register "r".
macro(bits:5) GetWord:r {
  code:m "$r" {
    UL;
  }
  code:C2 "($r)" {
    UL; LKR(m); ADR(m); LD(C2); UL;
  }
  code:C2 "($r + $v)" {
    LD(C2); UL; ADD(C2,m); LKR(m); ADR(C2); LD(C2); UL;
  }
  code:C2 "(SP)" {
    UL; LK(STACK); ADR(SP); LD(C2); UL;
  }
  code:C2 "(SP + $v)" {
    LD(C2); UL; ADD(C2,SP); LK(STACK); ADR(C2); LD(C2); UL;
  }
  code:C2 "(FP)" {
    UL; LK(STACK); ADR(FP); LD(C2); UL;
  }
  code:C2 "(FP + $v)" {
    LD(C2); UL; ADD(C2,FP); LK(STACK); ADR(C2); LD(C2); UL;
  }
  code:C2 "$v" {
    LD(C2); UL;
  }
  code:C2 "S($v)" {
    LD(C2); UL; LK(STACK); ADR(C2); LD(C2); UL;
  }
  code:C2 "D($v)" {
    LD(C2); UL; LK(DATA); ADR(C2); LD(C2); UL;
  }
  code:C2 "E($v)" {
    LD(C2); UL; LK(EXTRA); ADR(C2); LD(C2); UL;
  }
}

# Returns a dword value as a register.
#
# Ends fetch phase.
# Modifies register "C0" and "C1" and returns result in register "R".
macro(bits:5) GetDword:R {
  code:M "$R" {
    UL;
  }
  code:CD "[$r]" {
    UL; LKR(m); ADR(m); LD(C0); LD(C1); UL;
  }
  code:CD "[$r + $v]" {
    LD(C0); UL; ADD(C0,m); LKR(m); ADR(C0); LD(C0); LD(C1); UL;
  }
  code:CD "[SP]" {
    UL; LK(STACK); ADR(SP); LD(C0); LD(C1); UL;
  }
  code:CD "[SP + $v]" {
    LD(C0); UL; ADD(C0,SP); LK(STACK); ADR(C0); LD(C0); LD(C1); UL;
  }
  code:CD "[FP]" {
    UL; LK(STACK); ADR(FP); LD(C0); LD(C1); UL;
  }
  code:CD "[FP + $v]" {
    LD(C0); UL; ADD(C0,FP); LK(STACK); ADR(C0); LD(C0); LD(C1); UL;
  }
  code:CD "$v" {
    LD(C0); UL;
  }
  code:CD "S[$v]" {
    LD(C0); UL; LK(STACK); ADR(C0); LD(C0); LD(C1); UL;
  }
  code:CD "D[$v]" {
    LD(C0); UL; LK(DATA); ADR(C0); LD(C0); LD(C1); UL;
  }
  code:CD "E[$v]" {
    LD(C0); UL; LK(EXTRA); ADR(C0); LD(C0); LD(C1); UL;
  }
}

# Returns a 16-bit mask for a specified bit position (0-15) otherwise
# returns zero
#
# Ends fetch phase.
# Requires C1=0
# Modifies C0, C2.
macro(bits:5) Get16BitMask:r {
  code:C0 "$r" {
    UL;
    MOVI(C2,15);
    CMP(C2,m);
    JC(NS,@start);
    MOVI(C0,0);
    JP(@done);
  @start:
    MOV(C2,m);
    MOVI(C0,1);
    CMP(m,C1);
    JC(Z,@done);
  @shift:
    SL(C0);
    JD(C2,@shift);
  @done:
    MSS(_);
  }

  code:C0 "0"  { UL; MOVI(C0,0x01); }
  code:C0 "1"  { UL; MOVI(C0,0x02); }
  code:C0 "2"  { UL; MOVI(C0,0x04); }
  code:C0 "3"  { UL; MOVI(C0,0x08); }
  code:C0 "4"  { UL; MOVI(C0,0x10); }
  code:C0 "5"  { UL; MOVI(C0,0x20); }
  code:C0 "6"  { UL; MOVI(C0,0x40); }
  code:C0 "7"  {
    UL; MOVI(C0,0x40);
    SL(C0);
  }
  code:C0 "8"  {
    UL; MOVI(C0,0x40);
    SL(C0); SL(C0);
  }
  code:C0 "9"  {
    UL; MOVI(C0,0x40);
    SL(C0); SL(C0); SL(C0);
  }
  code:C0 "10" {
    UL; MOVI(C0,0x40);
    SL(C0); SL(C0); SL(C0); SL(C0);
  }
  code:C0 "11" {
    UL; MOVI(C0,0x40);
    SL(C0); SL(C0); SL(C0); SL(C0); SL(C0);
  }
  code:C0 "12" {
    UL; MOVI(C0,0x40);
    SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0);
  }
  code:C0 "13" {
    UL; MOVI(C0,0x40);
    SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0);
  }
  code:C0 "14" {
    UL; MOVI(C0,0x40);
    SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0);
  }
  code:C0 "15" {
    UL; MOVI(C0,0x40);
    SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0);
  }
}

# Returns a 32-bit mask for a specified bit position (0-31) otherwise
# returns zero
#
# Ends fetch phase.
# Requires: C0=0 and C1=0
# Modifies: C0, C1, C2
macro(bits:6) Get32BitMask:R {
  code:CD "$r" {
    UL;
    MOVI(C2,16);
    CMP(C2,m);
    JC(S,@upper);
    JC(Z,@sixteen);
    MOVI(C0,1);
    CMP(m,C1);
    JC(Z,@done);
    MOV(C2,m);
  @shift_lower:
    SL(C0);
    JD(C2,@shift_lower);
    JP(@done);
  @sixteen:
    MOVI(C1,1);
    JP(@done);
  @upper:
    MOVI(C2,31);
    CMP(C2,m);
    JC(NS,@start_upper);
    MOVI(C0,0);
    JP(@done);
  @start_upper:
    MOV(C2,m);
    ADDI(C2,-16);
    MOVI(C1,1);
    CMP(C2,C0);
    JC(Z,@done);
  @shift_upper:
    SL(C1);
    JD(C2,@shift_upper);
  @done:
    MSS(_);
  }

  code:CD "0"  { UL; MOVI(C0,0x0001); }
  code:CD "1"  { UL; MOVI(C0,0x0002); }
  code:CD "2"  { UL; MOVI(C0,0x0004); }
  code:CD "3"  { UL; MOVI(C0,0x0008); }
  code:CD "4"  { UL; MOVI(C0,0x0010); }
  code:CD "5"  { UL; MOVI(C0,0x0020); }
  code:CD "6"  { UL; MOVI(C0,0x0040); }
  code:CD "7"  {
    UL; MOVI(C0,0x0040);
    SL(C0);
  }
  code:CD "8"  {
    UL; MOVI(C0,0x0040);
    SL(C0); SL(C0);
  }
  code:CD "9"  {
    UL; MOVI(C0,0x0040);
    SL(C0); SL(C0); SL(C0);
  }
  code:CD "10" {
    UL; MOVI(C0,0x0040);
    SL(C0); SL(C0); SL(C0); SL(C0);
  }
  code:CD "11" {
    UL; MOVI(C0,0x0040);
    SL(C0); SL(C0); SL(C0); SL(C0); SL(C0);
  }
  code:CD "12" {
    UL; MOVI(C0,0x0040);
    SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0);
  }
  code:CD "13" {
    UL; MOVI(C0,0x0040);
    SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0);
  }
  code:CD "14" {
    UL; MOVI(C0,0x0040);
    SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0);
  }
  code:CD "15" {
    UL; MOVI(C0,0x0040);
    SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0); SL(C0);
  }
  code:CD "16"  { UL; MOVI(C1,0x0001); }
  code:CD "17"  { UL; MOVI(C1,0x0002); }
  code:CD "18"  { UL; MOVI(C1,0x0004); }
  code:CD "19"  { UL; MOVI(C1,0x0008); }
  code:CD "20"  { UL; MOVI(C1,0x0010); }
  code:CD "21"  { UL; MOVI(C1,0x0020); }
  code:CD "22"  { UL; MOVI(C1,0x0040); }
  code:CD "23"  {
    UL; MOVI(C1,0x0040);
    SL(C1);
  }
  code:CD "24"  {
    UL; MOVI(C1,0x0040);
    SL(C1); SL(C1);
  }
  code:CD "25"  {
    UL; MOVI(C1,0x0040);
    SL(C1); SL(C1); SL(C1);
  }
  code:CD "26" {
    UL; MOVI(C1,0x0040);
    SL(C1); SL(C1); SL(C1); SL(C1);
  }
  code:CD "27" {
    UL; MOVI(C1,0x0040);
    SL(C1); SL(C1); SL(C1); SL(C1); SL(C1);
  }
  code:CD "28" {
    UL; MOVI(C1,0x0040);
    SL(C1); SL(C1); SL(C1); SL(C1); SL(C1); SL(C1);
  }
  code:CD "29" {
    UL; MOVI(C1,0x0040);
    SL(C1); SL(C1); SL(C1); SL(C1); SL(C1); SL(C1); SL(C1);
  }
  code:CD "30" {
    UL; MOVI(C1,0x0040);
    SL(C1); SL(C1); SL(C1); SL(C1); SL(C1); SL(C1); SL(C1); SL(C1);
  }
  code:CD "31" {
    UL; MOVI(C1,0x0040);
    SL(C1); SL(C1); SL(C1); SL(C1); SL(C1); SL(C1); SL(C1); SL(C1); SL(C1);
  }
}

################################################################################
## NOP
##
## Cycles: 3
## ZSCO: ----
##
## Minimal instruction that does nothing.
################################################################################

instruction(opcode:0) NOP {
  UL;
}

################################################################################
## HALT
##
## Cycles: 3
## ZSCO: ----
##
## Puts the core into the IDLE state. Interrupts will still be triggered and
## executed, but the core will stay idle until it is reset to a new code
## location.
################################################################################

instruction HALT {
  UL;
  ADDI(IP,-1);  # Reset IP so core stays halted after interrupt
  HALT;         # Put the core into idle state.
}

################################################################################
## WAIT <reg>
##
## Cycles: 3+ ()
## ZSCO: ---X
##
## Puts the core into the WAIT state for at least the number of cycles
## specified. Interrupts may still be executed during the WAIT state, but
## cannot recursively call WAIT themselves.
##
## After a successful WAIT execution (it was not called recursively from within
## an interrupt), the provided register will be update with the number of
## additional cycles taken. This may be longer than the requested time due to
## an interrupt occurring or the core getting locked.
##
## On failure, the O flag is set. Otherwise it is cleared.
################################################################################

instruction WAIT "$r" {
  UL;
  WAIT(a);
}

################################################################################
## MOV <dst> <src>
##
## Cycles: 4+
## ZSCO: ----
##
## Variants:
##    MOV.LW <reg> <word-value>
##    MOV.LD <dreg> <dword-value>
##    MOV.SW <word-address> <reg>
##    MOV.SD <dword-address> <dreg>
##    MOV.S  <sreg> <reg>
##    MOV.S  <reg> <sreg>
##
## Moves (copies) the value from from <src> into <dst>.
################################################################################

macro(bits:5) LoadWord(p) {
  code "$r"         { UL; MOV(p,m); }
  code "($r)"       { UL; LKR(m); ADR(m); LD(p); UL; }
  code "($r + $v)"  { LD(C2); UL; ADD(C2,m); LKR(m); ADR(C2); LD(p); UL; }
  code "(SP)"       { UL; LK(STACK); ADR(SP); LD(p); UL; }
  code "(SP + $v)"  { LD(C2); UL; ADD(C2,SP); LK(STACK); ADR(C2); LD(p); UL; }
  code "(FP)"       { UL; LK(STACK); ADR(FP); LD(p); UL; }
  code "(FP + $v)"  { LD(C2); UL; ADD(C2,FP); LK(STACK); ADR(C2); LD(p); UL; }
  code "$v"         { LD(p); UL; }
  code "S($v)"      { LD(C2); UL; LK(STACK); ADR(C2); LD(p); UL; }
  code "D($v)"      { LD(C2); UL; LK(DATA); ADR(C2); LD(p); UL; }
  code "E($v)"      { LD(C2); UL; LK(EXTRA); ADR(C2); LD(p); UL; }
}

instruction MOV.LW "$r, $m" {
  $LoadWord(a);
}

macro(bits:5) LoadDword(P) {
  code "$R" {
    UL; MOV(p0,m0); MOV(p1,m1);
  }
  code "[$r]" {
    UL; LKR(m); ADR(m); LD(p0); LD(p1); UL;
  }
  code "[$r + $v]" {
    LD(C2); UL; ADD(C2,m); LKR(m); ADR(C2); LD(p0); LD(p1); UL;
  }
  code "[SP]" {
    UL; LK(STACK); ADR(SP); LD(p0); LD(p1); UL;
  }
  code "[SP + $v]" {
    LD(C2); UL; ADD(C2,SP); LK(STACK); ADR(C2); LD(p0); LD(p1); UL;
  }
  code "[FP]" {
    UL; LK(STACK); ADR(FP); LD(p0); LD(p1); UL;
  }
  code "[FP + $v]" {
    LD(C2); UL; ADD(C2,FP); LK(STACK); ADR(C2); LD(p0); LD(p1); UL;
  }
  code "$V" {
    LD(p0); LD(p1); UL;
  }
  code "S[$v]" {
    LD(C2); UL; LK(STACK); ADR(C2); LD(p0); LD(p1); UL;
  }
  code "D[$v]" {
    LD(C2); UL; LK(DATA); ADR(C2); LD(p0); LD(p1); UL;
  }
  code "E[$v]" {
    LD(C2); UL; LK(EXTRA); ADR(C2); LD(p0); LD(p1); UL;
  }
}

instruction MOV.LD "$R, $m" {
  $LoadDword(A);
}

macro(bits:5) StoreWord(p) {
  code "($r)"       { UL; LKR(m); ADR(m); ST(p); UL; }
  code "($r + $v)"  { LD(C2); UL; ADD(C2,m); LKR(m); ADR(C2); ST(p); UL; }
  code "(SP)"       { UL; LK(STACK); ADR(SP); ST(p); UL; }
  code "(SP + $v)"  { LD(C2); UL; ADD(C2,SP); LK(STACK); ADR(C2); ST(p); UL; }
  code "(FP)"       { UL; LK(STACK); ADR(FP); ST(p); UL; }
  code "(FP + $v)"  { LD(C2); UL; ADD(C2,FP); LK(STACK); ADR(C2); ST(p); UL; }
  code "S($v)"      { LD(C2); UL; LK(STACK); ADR(C2); ST(p); UL; }
  code "D($v)"      { LD(C2); UL; LK(DATA); ADR(C2); ST(p); UL; }
  code "E($v)"      { LD(C2); UL; LK(EXTRA); ADR(C2); ST(p); UL; }
}

instruction MOV.SW "$m, $r" {
  $StoreWord(b);
}

macro(bits:5) StoreDword(P) {
  code "[$r]" {
    UL; LKR(m); ADR(m); ST(p0); ST(p1); UL;
  }
  code "[$r + $v]" {
    LD(C2); UL; ADD(C2,m); LKR(m); ADR(C2); ST(p0); ST(p1); UL;
  }
  code "[SP]" {
    UL; LK(STACK); ADR(SP); ST(p0); ST(p1); UL;
  }
  code "[SP + $v]" {
    LD(C2); UL; ADD(C2,SP); LK(STACK); ADR(C2); ST(p0); ST(p1); UL;
  }
  code "[FP]" {
    UL; LK(STACK); ADR(FP); ST(p0); ST(p1); UL;
  }
  code "[FP + $v]" {
    LD(C2); UL; ADD(C2,FP); LK(STACK); ADR(C2); ST(p0); ST(p1); UL;
  }
  code "S[$v]" {
    LD(C2); UL; LK(STACK); ADR(C2); ST(p0); ST(p1); UL;
  }
  code "D[$v]" {
    LD(C2); UL; LK(DATA); ADR(C2); ST(p0); ST(p1); UL;
  }
  code "E[$v]" {
    LD(C2); UL; LK(EXTRA); ADR(C2); ST(p0); ST(p1); UL;
  }
}

instruction MOV.SD "$m, $R" {
  $StoreDword(B);
}

macro MoveSReg {
  code "$r, BC" { UL; MOV(m,BC); }
  code "$r, BS" { UL; MOV(m,BS); }
  code "$r, BD" { UL; MOV(m,BD); }
  code "$r, BE" { UL; MOV(m,BE); }
  code "$r, FP" { UL; MOV(m,FP); }
  code "$r, SP" { UL; MOV(m,SP); }
  code "BC, $r" { UL; MOV(BC,m); }
  code "BS, $r" { UL; MOV(BS,m); }
  code "BD, $r" { UL; MOV(BD,m); }
  code "BE, $r" { UL; MOV(BE,m); }
  code "FP, $r" { UL; MOV(FP,m); }
  code "SP, $r" { UL; MOV(SP,m); }
  code "BC, $v" { LD(C0); UL; MOV(BC,C0); }
  code "BS, $v" { LD(C0); UL; MOV(BS,C0); }
  code "BD, $v" { LD(C0); UL; MOV(BD,C0); }
  code "BE, $v" { LD(C0); UL; MOV(BE,C0); }
  code "FP, $v" { LD(C0); UL; MOV(FP,C0); }
  code "SP, $v" { LD(C0); UL; MOV(SP,C0); }
}

instruction MOV.S "$m" {
  $MoveSReg;
}

################################################################################
## MVQ <dst> <value>
##
## Cycles: 4-5
## ZSCO: ----
##
## Variants:
##    MVQ.LW <reg> <0..31>
##    MVQ.LD <dreg> <0..31>
##
## Moves the immediate value in the range [0,31] to the specified register.
################################################################################

instruction MVQ.LW "$r, $#5" {
  UL; MOV(a,C1);
}

instruction MVQ.LD "$R, $#5" {
  UL; MOV(a0,C1); MOVI(a1,0);
}

################################################################################
## PUSH <src>
##
## Cycles: 5+
## ZSCO: ----
##
## Variants:
##    PUSH.W <word-value>
##    PUSH.D <dword-value>
##
## Pushes the value onto the stack, updating SP.
################################################################################

instruction PUSH.W "$m" {
  $GetWord;
  LK(STACK); ADR(SP); STP(C2); LAD(SP); UL;
}

instruction PUSH.D "$m" {
  $GetDword;
  LK(STACK); ADR(SP); STP(C1); STP(C0); LAD(SP); UL;
}

################################################################################
## POP <dst>
##
## Cycles: 5+
## ZSCO: ----
##
## Variants:
##    POP.W <reg>
##    POP.W <word-address>
##    POP.D <dreg>
##    POP.D <dword-address>
##
## Pops the value from the stack, updating SP. The destination address is
## determined *after* the the value is popped, which affects addresses using an
## offset from SP.
################################################################################

macro PopWord {
  code "$r" {
    UL;
    LK(STACK); ADR(SP); LD(m); LAD(SP); UL;
  }
  code "($r)" {
    UL;
    LK(STACK); ADR(SP); LD(C2); LAD(SP); UL;
    LKR(m); ADR(m); ST(C2); UL;
  }
  code "($r + $v)" {
    LD(C0); UL;
    LK(STACK); ADR(SP); LD(C2); LAD(SP); UL;
    ADD(C0,m); LKR(m); ADR(C0); ST(C2); UL;
  }
  code "(SP)" {
    UL;
    LK(STACK);
      ADR(SP); LD(C2); LAD(SP);
      ST(C2);
    UL;
  }
  code "(SP + $v)" {
    LD(C0); UL;
    LK(STACK);
      ADR(SP); LD(C2); LAD(SP);
      ADD(C0,SP); ADR(C0); ST(C2);
    UL;
  }
  code "(FP)" {
    UL;
    LK(STACK);
      ADR(SP); LD(C2); LAD(SP);
      ADR(FP); ST(C2);
    UL;
  }
  code "(FP + $v)" {
    LD(C0); UL;
    LK(STACK);
      ADR(SP); LD(C2); LAD(SP);
      ADD(C0,FP); ADR(C0); ST(C2);
    UL;
  }
  code "S($v)" {
    LD(C0); UL;
    LK(STACK);
      ADR(SP); LD(C2); LAD(SP);
      ADR(C0); ST(C2);
    UL;
  }
  code "D($v)" {
    LD(C0); UL;
    LK(STACK); ADR(SP); LD(C2); LAD(SP); UL;
    LK(DATA); ADR(C0); ST(C2); UL;
  }
  code "E($v)" {
    LD(C0); UL;
    LK(STACK); ADR(SP); LD(C2); LAD(SP); UL;
    LK(EXTRA); ADR(C0); ST(C2); UL;
  }
}

instruction POP.W "$m" {
  $PopWord;
}

macro PopDword {
  code "$R" {
    UL;
    LK(STACK); ADR(SP); LD(m0); LD(m1); LAD(SP); UL;
  }
  code "[$r]" {
    UL;
    LK(STACK); ADR(SP); LD(C0); LD(C1); LAD(SP); UL;
    LKR(m); ADR(m); ST(C0); ST(C1); UL;
  }
  code "[$r + $v]" {
    LD(C2); UL;
    LK(STACK); ADR(SP); LD(C0); LD(C1); LAD(SP); UL;
    ADD(C2,m); LKR(m); ADR(C2); ST(C0); ST(C1); UL;
  }
  code "[SP]" {
    UL;
    LK(STACK);
      ADR(SP); LD(C0); LD(C1); LAD(SP);
      ST(C0); ST(C1);
    UL;
  }
  code "[SP + $v]" {
    LD(C2); UL;
    LK(STACK);
      ADR(SP); LD(C0); LD(C1); LAD(SP);
      ADD(C2,SP); ADR(C2); ST(C0); ST(C1);
    UL;
  }
  code "[FP]" {
    UL;
    LK(STACK);
      ADR(SP); LD(C0); LD(C1); LAD(SP);
      ADR(FP); ST(C0); ST(C1);
    UL;
  }
  code "[FP + $v]" {
    LD(C2); UL;
    LK(STACK);
      ADR(SP); LD(C0); LD(C1); LAD(SP);
      ADD(C2,FP); ADR(C2); ST(C0); ST(C1);
    UL;
  }
  code "S[$v]" {
    LD(C2); UL;
    LK(STACK);
      ADR(SP); LD(C0); LD(C1); LAD(SP);
      ADR(C2); ST(C0); ST(C1);
    UL;
  }
  code "D[$v]" {
    LD(C2); UL;
    LK(STACK); ADR(SP); LD(C0); LD(C1); LAD(SP); UL;
    LK(DATA); ADR(C2); ST(C0); ST(C1); UL;
  }
  code "E[$v]" {
    LD(C2); UL;
    LK(STACK); ADR(SP); LD(C0); LD(C1); LAD(SP); UL;
    LK(EXTRA); ADR(C2); ST(C0); ST(C1); UL;
  }
}

instruction POP.D "$m" {
  $PopDword;
}

################################################################################
## SWP <a> <b>
##
## Cycles: 6+
## ZSCO: ----
##
## Variants:
##    SWP.W <reg> <reg>
##    SWP.W <reg> <word-address>
##    SWP.D <dreg> <dreg>
##    SWP.D <dreg> <dword-address>
##
## Swaps the contents of the specified register <a> with a register or memory
## address value <b>
################################################################################

macro SwapWord(p) {
  code "$r" {
    UL;
    MOV(C0,p); MOV(p,m); MOV(m,C0);
  }
  code "($r)" {
    UL;
    MOV(C0,p); LKR(m); ADR(m); LD(p); STP(C0); UL;
  }
  code "($r + $v)" {
    LD(C2); UL; ADD(C2,m);
    MOV(C0,p); LKR(m); ADR(C2); LD(p); STP(C0); UL;
  }
  code "(SP)" {
    UL;
    MOV(C0,p); LK(STACK); ADR(SP); LD(p); STP(C0); UL;
  }
  code "(SP + $v)" {
    LD(C2); UL; ADD(C2,SP);
    MOV(C0,p); LK(STACK); ADR(C2); LD(p); STP(C0); UL;
  }
  code "(FP)" {
    UL;
    MOV(C0,p); LK(STACK); ADR(FP); LD(p); STP(C0); UL;
  }
  code "(FP + $v)" {
    LD(C2); UL; ADD(C2,FP);
    MOV(C0,p); LK(STACK); ADR(C2); LD(p); STP(C0); UL;
  }
  code "S($v)" {
    LD(C2); UL;
    MOV(C0,p); LK(STACK); ADR(C2); LD(p); STP(C0); UL;
  }
  code "D($v)" {
    LD(C2); UL;
    MOV(C0,p); LK(DATA); ADR(C2); LD(p); STP(C0); UL;
  }
  code "E($v)" {
    LD(C2); UL;
    MOV(C0,p); LK(EXTRA); ADR(C2); LD(p); STP(C0); UL;
  }
}

instruction SWP.W "$r, $m" {
  $SwapWord(a);
}

macro SwapDword(P) {
  code "$R" {
    UL;
    MOV(C0,p0); MOV(p0,m0); MOV(m0,C0);
    MOV(C1,p1); MOV(p1,m1); MOV(m1,C1);
  }
  code "($r)" {
    UL;
    MOV(C0,p0); MOV(C1,p1);
    LKR(m); ADR(m); LD(p0); LD(p1); STP(C1); STP(C0); UL;
  }
  code "($r + $v)" {
    LD(C2); UL; ADD(C2,m);
    MOV(C0,p0); MOV(C1,p1);
    LKR(m); ADR(C2); LD(p0); LD(p1); STP(C1); STP(C0); UL;
  }
  code "(SP)" {
    UL;
    MOV(C0,p0); MOV(C1,p1);
    LK(STACK); ADR(SP); LD(p0); LD(p1); STP(C1); STP(C0); UL;
  }
  code "(SP + $v)" {
    LD(C2); UL; ADD(C2,SP);
    MOV(C0,p0); MOV(C1,p1);
    LK(STACK); ADR(C2); LD(p0); LD(p1); STP(C1); STP(C0); UL;
  }
  code "(FP)" {
    UL;
    MOV(C0,p0); MOV(C1,p1);
    LK(STACK); ADR(FP); LD(p0); LD(p1); STP(C1); STP(C0); UL;
  }
  code "(FP + $v)" {
    LD(C2); UL; ADD(C2,FP);
    MOV(C0,p0); MOV(C1,p1);
    LK(STACK); ADR(C2); LD(p0); LD(p1); STP(C1); STP(C0); UL;
  }
  code "S($v)" {
    LD(C2); UL;
    MOV(C0,p0); MOV(C1,p1);
    LK(STACK); ADR(C2); LD(p0); LD(p1); STP(C1); STP(C0); UL;
  }
  code "D($v)" {
    LD(C2); UL;
    MOV(C0,p0); MOV(C1,p1);
    LK(DATA); ADR(C2); LD(p0); LD(p1); STP(C1); STP(C0); UL;
  }
  code "E($v)" {
    LD(C2); UL;
    MOV(C0,p0); MOV(C1,p1);
    LK(EXTRA); ADR(C2); LD(p0); LD(p1); STP(C1); STP(C0); UL;
  }
}

instruction SWP.D "$R, $m" {
  $SwapDword(A);
}


################################################################################
## NEG <register>
##
## Cycles: 5-9
## ZSCO: XX00
##
## Variants:
##    NEG.W <reg>
##    NEG.D <dreg>
##
## Negates the value in the specified register.
################################################################################

instruction NEG.W "$r" {
  UL;
  # The contract is to always clear the CO flags, which SUB won't do, so we need
  # to clear them explicitly before returning the status
  SUB(C0,a); MSC(CO); MSR(ZSCO,ZSCO);

  # Copy result back to the register
  MOV(a,C0);
}

instruction NEG.D "$R" {
  UL;

  # Proactively set zero bit here based on low-order result.
  SUB(C0,a0); MSR(Z,Z);

  # Clear the zero bit (but don't set it) based on high-order result.
  SBC(C1,a1); MSC(CO); MSR(ZSCO,_SCO);

  # Copy result back to the register
  MOV(a0,C0); MOV(a1,C1);
}

################################################################################
## ADD <register>, <value>
##
## Cycles: 4+
## ZSCO: XXXX
##
## Variants:
##    ADD.W <reg>, <word-value>
##    ADD.D <dreg>, <dword-value>
##    ADD.S SP, <word-value>
##
## Adds a value to the specified register.
################################################################################

instruction ADD.W "$r, $m" {
  $GetWord;
  ADD(a,r);
  MSR(ZSCO,ZSCO);
}

instruction ADD.D "$R, $m" {
  $GetDword;
  ADD(a0,r0);
  MSR(Z,Z);
  ADC(a1,r1);
  MSR(ZSCO,_SCO);
}

instruction ADD.S "SP, $m" {
  $GetWord;
  ADD(SP,r);
  MSR(ZSCO,ZSCO);
}

################################################################################
## ADQ <register>, <value>
##
## Cycles: 4-5
## ZSCO: XXXX
##
## Variants:
##    ADQ.W <reg>, <0..31>
##    ADQ.D <dreg>, <0..31>
##    ADQ.S SP, <0..31>
##
## Adds an immediate value to the specified register.
################################################################################

instruction ADQ.W "$r, $#5" {
  UL;
  ADD(a,C1);
  MSR(ZSCO,ZSCO);
}

instruction ADQ.D "$R, $#5" {
  UL;
  ADD(a0,C1);
  MSR(Z,Z);
  ADC(a1,C2);
  MSR(ZSCO,_SCO);
}

instruction ADQ.S "SP, $#5" {
  UL;
  ADD(SP,C1);
  MSR(ZSCO,ZSCO);
}

################################################################################
## ADC <register>, <value>
##
## Cycles: 4+
## ZSCO: XXXX
##
## Variants:
##    ADC.W <reg>, <word-value>
##    ADC.D <dreg>, <dword-value>
##
## Adds a value to the specified register.
################################################################################

instruction ADC.W "$r, $m" {
  $GetWord;
  ADC(a,r);
  MSR(ZSCO,ZSCO);
}

instruction ADC.D "$R, $m" {
  $GetDword;
  ADC(a0,r0);
  MSR(Z,Z);
  ADC(a1,r1);
  MSR(ZSCO,_SCO);
}

################################################################################
## SUB <register>, <value>
##
## Cycles: 4+
## ZSCO: XXXX
##
## Variants:
##    SUB.W <reg>, <word-value>
##    SUB.D <dreg>, <dword-value>
##    SUB.S SP, <word-value>
##
## Subtracts a value to the specified register.
################################################################################

instruction SUB.W "$r, $m" {
  $GetWord;
  SUB(a,r);
  MSR(ZSCO,ZSCO);
}

instruction SUB.D "$R, $m" {
  $GetDword;
  SUB(a0,r0);
  MSR(Z,Z);
  SBC(a1,r1);
  MSR(ZSCO,_SCO);
}

instruction SUB.S "SP, $m" {
  $GetWord;
  SUB(SP,r);
  MSR(ZSCO,ZSCO);
}

################################################################################
## SBQ <register>, <value>
##
## Cycles: 4-5
## ZSCO: XXXX
##
## Variants:
##    SBQ.W <reg>, <0..31>
##    SBQ.D <dreg>, <0..31>
##    SBQ.S SP, <0..31>
##
## Subtracts an immediate value to the specified register.
################################################################################

instruction SBQ.W "$r, $#5" {
  UL;
  SUB(a,C1);
  MSR(ZSCO,ZSCO);
}

instruction SBQ.D "$R, $#5" {
  UL;
  SUB(a0,C1);
  MSR(Z,Z);
  SBC(a1,C2);
  MSR(ZSCO,_SCO);
}

instruction SBQ.S "SP, $#5" {
  UL;
  SUB(SP,C1);
  MSR(ZSCO,ZSCO);
}

################################################################################
## SBC <register>, <value>
##
## Cycles: 4+
## ZSCO: XXXX
##
## Variants:
##    SBC.W <reg>, <word-value>
##    SBC.D <dreg>, <dword-value>
##
## Adds a value to the specified register.
################################################################################

instruction SBC.W "$r, $m" {
  $GetWord;
  SBC(a,r);
  MSR(ZSCO,ZSCO);
}

instruction SBC.D "$R, $m" {
  $GetDword;
  SBC(a0,r0);
  MSR(Z,Z);
  SBC(a1,r1);
  MSR(ZSCO,_SCO);
}

################################################################################
## NOT <register>
##
## Cycles: 5-9
## ZSCO: XX00
##
## Variants:
##    NOT.W <reg>
##    NOT.D <dreg>
##
## Bitwise NOT of the value in the specified register.
################################################################################

instruction NOT.W "$r" {
  UL;
  NOT(a,a); MSR(ZSCO,ZSCO);
}

instruction NOT.D "$R" {
  UL;
  NOT(a0,a0); MSR(Z,Z);
  NOT(a1,a1); MSR(ZSCO,_SCO);
}

################################################################################
## AND <register>, <value>
##
## Cycles: 4+
## ZSCO: XX00
##
## Variants:
##    AND.W <reg>, <word-value>
##    AND.D <dreg>, <dword-value>
##
## Bitwise AND a value to the specified register.
################################################################################

instruction AND.W "$r, $m" {
  $GetWord;
  AND(a,r);
  MSR(ZSCO,ZSCO);
}

instruction AND.D "$R, $m" {
  $GetDword;
  AND(a0,r0);
  MSR(Z,Z);
  AND(a1,r1);
  MSR(ZSCO,_SCO);
}

################################################################################
## OR <register>, <value>
##
## Cycles: 4+
## ZSCO: XX00
##
## Variants:
##    OR.W <reg>, <word-value>
##    OR.D <dreg>, <dword-value>
##
## Bitwise OR a value to the specified register.
################################################################################

instruction OR.W "$r, $m" {
  $GetWord;
  OR(a,r);
  MSR(ZSCO,ZSCO);
}

instruction OR.D "$R, $m" {
  $GetDword;
  OR(a0,r0);
  MSR(Z,Z);
  OR(a1,r1);
  MSR(ZSCO,_SCO);
}

################################################################################
## XOR <register>, <value>
##
## Cycles: 4+
## ZSCO: XX00
##
## Variants:
##    XOR.W <reg>, <word-value>
##    XOR.D <dreg>, <dword-value>
##
## Bitwise XOR a value to the specified register.
################################################################################

instruction XOR.W "$r, $m" {
  $GetWord;
  XOR(a,r);
  MSR(ZSCO,ZSCO);
}

instruction XOR.D "$R, $m" {
  $GetDword;
  XOR(a0,r0);
  MSR(Z,Z);
  XOR(a1,r1);
  MSR(ZSCO,_SCO);
}

################################################################################
## SHL <register>, <value>
##
## Cycles: 5+
## ZSCO: XXX0
##
## Variants:
##    SHL.W <reg>, <reg>
##    SHL.W <reg>, <1..16>
##    SHL.D <dreg>, <reg>
##    SHL.D <dreg>, <1..32>
##
## Logical shift left of the register by the specified number of bits. The last
## bit shifted out sets the value of the "C" flag.
################################################################################

macro(bits:5) LogicalShiftLeft16(p) {
  code "$r" {
    # Shift zero bits?
    CMP(m,C0);
    JC(Z,@zero);

    # Shift > 16 bits?
    MOVI(C2,16);
    CMP(C2,m);
    JC(S,@max);

    # Shift 1-16 bits
    MOV(C2,m);
  @shift:
    SL(p);
    JD(C2,@shift);
    MSR(ZSCO,ZSCO);
    END;

  @max:
    MOVI(p,0);
    MSC(SCO); MSS(Z); MSR(SCO,Z);
    END;

  @zero:
    CMP(p,C0); MSR(ZSCO,ZSCO);
  }

  code "1" {
    SL(p);
    MSR(ZSCO,ZSCO);
  }
  code "2" {
    SL(p); SL(p);
    MSR(ZSCO,ZSCO);
  }
  code "3" {
    SL(p); SL(p); SL(p);
    MSR(ZSCO,ZSCO);
  }
  code "4" {
    SL(p); SL(p); SL(p); SL(p);
    MSR(ZSCO,ZSCO);
  }
  code "5" {
    SL(p); SL(p); SL(p); SL(p); SL(p);
    MSR(ZSCO,ZSCO);
  }
  code "6" {
    SL(p); SL(p); SL(p); SL(p); SL(p); SL(p);
    MSR(ZSCO,ZSCO);
  }
  code "7" {
    SL(p); SL(p); SL(p); SL(p); SL(p); SL(p); SL(p);
    MSR(ZSCO,ZSCO);
  }
  code "8" {
    SL(p); SL(p); SL(p); SL(p); SL(p); SL(p); SL(p); SL(p);
    MSR(ZSCO,ZSCO);
  }
  code "9" {
    SL(p); SL(p); SL(p); SL(p); SL(p); SL(p); SL(p); SL(p);
    SL(p);
    MSR(ZSCO,ZSCO);
  }
  code "10" {
    SL(p); SL(p); SL(p); SL(p); SL(p); SL(p); SL(p); SL(p);
    SL(p); SL(p);
    MSR(ZSCO,ZSCO);
  }
  code "11" {
    SL(p); SL(p); SL(p); SL(p); SL(p); SL(p); SL(p); SL(p);
    SL(p); SL(p); SL(p);
    MSR(ZSCO,ZSCO);
  }
  code "12" {
    SL(p); SL(p); SL(p); SL(p); SL(p); SL(p); SL(p); SL(p);
    SL(p); SL(p); SL(p); SL(p);
    MSR(ZSCO,ZSCO);
  }
  code "13" {
    SL(p); SL(p); SL(p); SL(p); SL(p); SL(p); SL(p); SL(p);
    SL(p); SL(p); SL(p); SL(p); SL(p);
    MSR(ZSCO,ZSCO);
  }
  code "14" {
    SL(p); SL(p); SL(p); SL(p); SL(p); SL(p); SL(p); SL(p);
    SL(p); SL(p); SL(p); SL(p); SL(p); SL(p);
    MSR(ZSCO,ZSCO);
  }
  code "15" {
    SL(p); SL(p); SL(p); SL(p); SL(p); SL(p); SL(p); SL(p);
    SL(p); SL(p); SL(p); SL(p); SL(p); SL(p); SL(p);
    MSR(ZSCO,ZSCO);
  }
  code "16" {
    SR(p); MOVI(p,0);
    MSS(Z); MSR(ZSCO,ZSCO);
  }
}

instruction SHL.W "$r, $m" {
  UL; $LogicalShiftLeft16(a);
}

macro(bits:6) LogicalShiftLeft32(P) {
  code "$r" {
    # Shift zero bits?
    CMP(m,C0);
    JC(Z,@zero);

    # Shift > 32 bits?
    MOVI(C2,32);
    CMP(C2,m);
    JC(S,@max);

    # Shift 1-32 bits
    MOV(C2,m);
  @shift:
    SL(p0); MSR(Z,Z); RLC(p1);
    JD(C2,@shift);
    MSR(ZSCO,SCO);
    END;

  @max:
    MOVI(p0,0); MOVI(p1,0);
    MSC(SCO); MSS(Z); MSR(SCO,Z);
    END;

  @zero:
    CMP(p0,C0); MSR(Z,Z); CMP(p1,C0); MSR(ZCSO,CSO);
  }

  code "1" {
    SL(p0); MSR(Z,Z); RLC(p1);
    MSR(ZSCO,SCO);
  }
  code "2" {
    SL(p0); RLC(p1);
    SL(p0); MSR(Z,Z); RLC(p1);
    MSR(ZSCO,SCO);
  }
  code "3" {
    SL(p0); RLC(p1); SL(p0); RLC(p1);
    SL(p0); MSR(Z,Z); RLC(p1);
    MSR(ZSCO,SCO);
  }
  code "4" {
    SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1);
    SL(p0); MSR(Z,Z); RLC(p1);
    MSR(ZSCO,SCO);
  }
  code "5" {
    SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1);
   
   SL(p0); MSR(Z,Z); RLC(p1);
    MSR(ZSCO,SCO);
  }
  code "6" {
    SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1);
    SL(p0); RLC(p1);
    SL(p0); MSR(Z,Z); RLC(p1);
    MSR(ZSCO,SCO);
  }
  code "7" {
    SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1);
    SL(p0); RLC(p1); SL(p0); RLC(p1);
    SL(p0); MSR(Z,Z); RLC(p1);
    MSR(ZSCO,SCO);
  }
  code "8" {
    SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1);
    SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1);
    SL(p0); MSR(Z,Z); RLC(p1);
    MSR(ZSCO,SCO);
  }
  code "9" {
    SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1);
    SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1);
   
   SL(p0); MSR(Z,Z); RLC(p1);
    MSR(ZSCO,SCO);
  }
  code "10" {
    SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1);
    SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1);
    SL(p0); RLC(p1);
    SL(p0); MSR(Z,Z); RLC(p1);
    MSR(ZSCO,SCO);
  }
  code "11" {
    SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1);
    SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1);
    SL(p0); RLC(p1); SL(p0); RLC(p1);
    SL(p0); MSR(Z,Z); RLC(p1);
    MSR(ZSCO,SCO);
  }
  code "12" {
    SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1);
    SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1);
    SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1);
    SL(p0); MSR(Z,Z); RLC(p1);
    MSR(ZSCO,SCO);
  }
  code "13" {
    SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1);
    SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1);
    SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1);
   
   SL(p0); MSR(Z,Z); RLC(p1);
    MSR(ZSCO,SCO);
  }
  code "14" {
    SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1);
    SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1);
    SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1);
    SL(p0); RLC(p1);
    SL(p0); MSR(Z,Z); RLC(p1);
    MSR(ZSCO,SCO);
  }
  code "15" {
    SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1);
    SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1);
    SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1); SL(p0); RLC(p1);
    SL(p0); RLC(p1); SL(p0); RLC(p1);
    SL(p0); MSR(Z,Z); RLC(p1);
    MSR(ZSCO,SCO);
  }
  code "16" {
    SR(p1); MSR(C,C); MOV(p1,p0); MOVI(p0,0);
    CMP(p1,C0); MSR(ZSO,ZSO);
  }
  code "17" {
    MOV(p1,p0); MOVI(p0,0);
    SL(p1);
    MSR(ZSCO,ZSCO);
  }
  code "18" {
    MOV(p1,p0); MOVI(p0,0);
    SL(p1); SL(p1);
    MSR(ZSCO,ZSCO);
  }
  code "19" {
    MOV(p1,p0); MOVI(p0,0);
    SL(p1); SL(p1); SL(p1);
    MSR(ZSCO,ZSCO);
  }
  code "20" {
    MOV(p1,p0); MOVI(p0,0);
    SL(p1); SL(p1); SL(p1); SL(p1);
    MSR(ZSCO,ZSCO);
  }
  code "21" {
    MOV(p1,p0); MOVI(p0,0);
    SL(p1); SL(p1); SL(p1); SL(p1); SL(p1);
    MSR(ZSCO,ZSCO);
  }
  code "22" {
    MOV(p1,p0); MOVI(p0,0);
    SL(p1); SL(p1); SL(p1); SL(p1); SL(p1); SL(p1);
    MSR(ZSCO,ZSCO);
  }
  code "23" {
    MOV(p1,p0); MOVI(p0,0);
    SL(p1); SL(p1); SL(p1); SL(p1); SL(p1); SL(p1); SL(p1);
    MSR(ZSCO,ZSCO);
  }
  code "24" {
    MOV(p1,p0); MOVI(p0,0);
    SL(p1); SL(p1); SL(p1); SL(p1); SL(p1); SL(p1); SL(p1); SL(p1);
    MSR(ZSCO,ZSCO);
  }
  code "25" {
    MOV(p1,p0); MOVI(p0,0);
    SL(p1); SL(p1); SL(p1); SL(p1); SL(p1); SL(p1); SL(p1); SL(p1);
    SL(p1);
    MSR(ZSCO,ZSCO);
  }
  code "26" {
    MOV(p1,p0); MOVI(p0,0);
    SL(p1); SL(p1); SL(p1); SL(p1); SL(p1); SL(p1); SL(p1); SL(p1);
    SL(p1); SL(p1);
    MSR(ZSCO,ZSCO);
  }
  code "27" {
    MOV(p1,p0); MOVI(p0,0);
    SL(p1); SL(p1); SL(p1); SL(p1); SL(p1); SL(p1); SL(p1); SL(p1);
    SL(p1); SL(p1); SL(p1);
    MSR(ZSCO,ZSCO);
  }
  code "28" {
    MOV(p1,p0); MOVI(p0,0);
    SL(p1); SL(p1); SL(p1); SL(p1); SL(p1); SL(p1); SL(p1); SL(p1);
    SL(p1); SL(p1); SL(p1); SL(p1);
    MSR(ZSCO,ZSCO);
  }
  code "29" {
    MOV(p1,p0); MOVI(p0,0);
    SL(p1); SL(p1); SL(p1); SL(p1); SL(p1); SL(p1); SL(p1); SL(p1);
    SL(p1); SL(p1); SL(p1); SL(p1); SL(p1);
    MSR(ZSCO,ZSCO);
  }
  code "30" {
    MOV(p1,p0); MOVI(p0,0);
    SL(p1); SL(p1); SL(p1); SL(p1); SL(p1); SL(p1); SL(p1); SL(p1);
    SL(p1); SL(p1); SL(p1); SL(p1); SL(p1); SL(p1);
    MSR(ZSCO,ZSCO);
  }
  code "31" {
    MOV(p1,p0); MOVI(p0,0);
    SL(p1); SL(p1); SL(p1); SL(p1); SL(p1); SL(p1); SL(p1); SL(p1);
    SL(p1); SL(p1); SL(p1); SL(p1); SL(p1); SL(p1); SL(p1);
    MSR(ZSCO,ZSCO);
  }
  code "32" {
    SR(p0); MOVI(p0,0); MOVI(p1,0);
    MSS(Z); MSC(SO); MSR(ZSCO,ZSCO);
  }
}

instruction SHL.D "$R, $m" {
  UL; $LogicalShiftLeft32(A);
}

################################################################################
## SHR <register>, <value>
##
## Cycles: 5+
## ZSCO: XXX0
##
## Variants:
##    SHR.W <reg>, <reg>
##    SHR.W <reg>, <1..16>
##    SHR.D <dreg>, <reg>
##    SHR.D <dreg>, <1..32>
##
## Logical shift right of the register by the specified number of bits. The last
## bit shifted out sets the value of the "C" flag.
################################################################################

macro(bits:5) LogicalShiftRight16(p) {
  code "$r" {
    # Shift zero bits?
    CMP(m,C0);
    JC(Z,@zero);

    # Shift > 16 bits?
    MOVI(C2,16);
    CMP(C2,m);
    JC(S,@max);

    # Shift 1-16 bits
    MOV(C2,m);
  @shift:
    SR(p);
    JD(C2,@shift);
    MSR(ZSCO,ZSCO);
    END;

  @max:
    MOVI(p,0);
    MSC(SCO); MSS(Z); MSR(SCO,Z);
    END;

  @zero:
    CMP(p,C0); MSR(ZSCO,ZSCO);
  }

  code "1" {
    SR(p);
    MSR(ZSCO,ZSCO);
  }
  code "2" {
    SR(p); SR(p);
    MSR(ZSCO,ZSCO);
  }
  code "3" {
    SR(p); SR(p); SR(p);
    MSR(ZSCO,ZSCO);
  }
  code "4" {
    SR(p); SR(p); SR(p); SR(p);
    MSR(ZSCO,ZSCO);
  }
  code "5" {
    SR(p); SR(p); SR(p); SR(p); SR(p);
    MSR(ZSCO,ZSCO);
  }
  code "6" {
    SR(p); SR(p); SR(p); SR(p); SR(p); SR(p);
    MSR(ZSCO,ZSCO);
  }
  code "7" {
    SR(p); SR(p); SR(p); SR(p); SR(p); SR(p); SR(p);
    MSR(ZSCO,ZSCO);
  }
  code "8" {
    SR(p); SR(p); SR(p); SR(p); SR(p); SR(p); SR(p); SR(p);
    MSR(ZSCO,ZSCO);
  }
  code "9" {
    SR(p); SR(p); SR(p); SR(p); SR(p); SR(p); SR(p); SR(p);
    SR(p);
    MSR(ZSCO,ZSCO);
  }
  code "10" {
    SR(p); SR(p); SR(p); SR(p); SR(p); SR(p); SR(p); SR(p);
    SR(p); SR(p);
    MSR(ZSCO,ZSCO);
  }
  code "11" {
    SR(p); SR(p); SR(p); SR(p); SR(p); SR(p); SR(p); SR(p);
    SR(p); SR(p); SR(p);
    MSR(ZSCO,ZSCO);
  }
  code "12" {
    SR(p); SR(p); SR(p); SR(p); SR(p); SR(p); SR(p); SR(p);
    SR(p); SR(p); SR(p); SR(p);
    MSR(ZSCO,ZSCO);
  }
  code "13" {
    SR(p); SR(p); SR(p); SR(p); SR(p); SR(p); SR(p); SR(p);
    SR(p); SR(p); SR(p); SR(p); SR(p);
    MSR(ZSCO,ZSCO);
  }
  code "14" {
    SR(p); SR(p); SR(p); SR(p); SR(p); SR(p); SR(p); SR(p);
    SR(p); SR(p); SR(p); SR(p); SR(p); SR(p);
    MSR(ZSCO,ZSCO);
  }
  code "15" {
    SR(p); SR(p); SR(p); SR(p); SR(p); SR(p); SR(p); SR(p);
    SR(p); SR(p); SR(p); SR(p); SR(p); SR(p); SR(p);
    MSR(ZSCO,ZSCO);
  }
  code "16" {
    SL(p); MOVI(p,0);
    MSS(Z); MSC(S); MSR(ZSCO,ZSCO);
  }
}

instruction SHR.W "$r, $m" {
  UL; $LogicalShiftRight16(a);
}

macro(bits:6) LogicalShiftRight32(P) {
  code "$r" {
    # Shift zero bits?
    CMP(m,C0);
    JC(Z,@zero);

    # Shift > 32 bits?
    MOVI(C2,32);
    CMP(C2,m);
    JC(S,@max);

    # Shift 1-32 bits
    MOV(C2,m);
  @shift:
    SR(p1); MSR(ZS,ZS); RRC(p0);
    JD(C2,@shift);
    MSR(ZCO,CO);
    END;

  @max:
    MOVI(p0,0); MOVI(p1,0);
    MSC(SCO); MSS(Z); MSR(SCO,Z);
    END;

  @zero:
    CMP(p0,C0); MSR(Z,Z); CMP(p1,C0); MSR(ZCSO,CSO);
  }

  code "1" {
    SR(p1); MSR(Z,Z); RRC(p0);
    MSC(S); MSR(ZSCO,SCO);
  }
  code "2" {
    SR(p1); RRC(p0);
    SR(p1); MSR(Z,Z); RRC(p0);
    MSC(S); MSR(ZSCO,SCO);
  }
  code "3" {
    SR(p1); RRC(p0); SR(p1); RRC(p0);
    SR(p1); MSR(Z,Z); RRC(p0);
    MSC(S); MSR(ZSCO,SCO);
  }
  code "4" {
    SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0);
    SR(p1); MSR(Z,Z); RRC(p0);
    MSC(S); MSR(ZSCO,SCO);
  }
  code "5" {
    SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0);
   
   SR(p1); MSR(Z,Z); RRC(p0);
    MSC(S); MSR(ZSCO,SCO);
  }
  code "6" {
    SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0);
    SR(p1); RRC(p0);
    SR(p1); MSR(Z,Z); RRC(p0);
    MSC(S); MSR(ZSCO,SCO);
  }
  code "7" {
    SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0);
    SR(p1); RRC(p0); SR(p1); RRC(p0);
    SR(p1); MSR(Z,Z); RRC(p0);
    MSC(S); MSR(ZSCO,SCO);
  }
  code "8" {
    SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0);
    SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0);
    SR(p1); MSR(Z,Z); RRC(p0);
    MSC(S); MSR(ZSCO,SCO);
  }
  code "9" {
    SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0);
    SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0);
   
   SR(p1); MSR(Z,Z); RRC(p0);
    MSC(S); MSR(ZSCO,SCO);
  }
  code "10" {
    SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0);
    SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0);
    SR(p1); RRC(p0);
    SR(p1); MSR(Z,Z); RRC(p0);
    MSC(S); MSR(ZSCO,SCO);
  }
  code "11" {
    SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0);
    SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0);
    SR(p1); RRC(p0); SR(p1); RRC(p0);
    SR(p1); MSR(Z,Z); RRC(p0);
    MSC(S); MSR(ZSCO,SCO);
  }
  code "12" {
    SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0);
    SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0);
    SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0);
    SR(p1); MSR(Z,Z); RRC(p0);
    MSC(S); MSR(ZSCO,SCO);
  }
  code "13" {
    SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0);
    SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0);
    SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0);
   
   SR(p1); MSR(Z,Z); RRC(p0);
    MSC(S); MSR(ZSCO,SCO);
  }
  code "14" {
    SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0);
    SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0);
    SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0);
    SR(p1); RRC(p0);
    SR(p1); MSR(Z,Z); RRC(p0);
    MSC(S); MSR(ZSCO,SCO);
  }
  code "15" {
    SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0);
    SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0);
    SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0); SR(p1); RRC(p0);
    SR(p1); RRC(p0); SR(p1); RRC(p0);
    SR(p1); MSR(Z,Z); RRC(p0);
    MSC(S); MSR(ZSCO,SCO);
  }
  code "16" {
    SL(p0); MSR(C,C); MOV(p0,p1); MOVI(p1,0);
    CMP(p0,C0); MSC(S); MSR(ZSO,ZSO);
  }
  code "17" {
    MOV(p0,p1); MOVI(p1,0);
    SR(p0);
    MSR(ZSCO,ZSCO);
  }
  code "18" {
    MOV(p0,p1); MOVI(p1,0);
    SR(p0); SR(p0);
    MSR(ZSCO,ZSCO);
  }
  code "19" {
    MOV(p0,p1); MOVI(p1,0);
    SR(p0); SR(p0); SR(p0);
    MSR(ZSCO,ZSCO);
  }
  code "20" {
    MOV(p0,p1); MOVI(p1,0);
    SR(p0); SR(p0); SR(p0); SR(p0);
    MSR(ZSCO,ZSCO);
  }
  code "21" {
    MOV(p0,p1); MOVI(p1,0);
    SR(p0); SR(p0); SR(p0); SR(p0); SR(p0);
    MSR(ZSCO,ZSCO);
  }
  code "22" {
    MOV(p0,p1); MOVI(p1,0);
    SR(p0); SR(p0); SR(p0); SR(p0); SR(p0); SR(p0);
    MSR(ZSCO,ZSCO);
  }
  code "23" {
    MOV(p0,p1); MOVI(p1,0);
    SR(p0); SR(p0); SR(p0); SR(p0); SR(p0); SR(p0); SR(p0);
    MSR(ZSCO,ZSCO);
  }
  code "24" {
    MOV(p0,p1); MOVI(p1,0);
    SR(p0); SR(p0); SR(p0); SR(p0); SR(p0); SR(p0); SR(p0); SR(p0);
    MSR(ZSCO,ZSCO);
  }
  code "25" {
    MOV(p0,p1); MOVI(p1,0);
    SR(p0); SR(p0); SR(p0); SR(p0); SR(p0); SR(p0); SR(p0); SR(p0);
    SR(p0);
    MSR(ZSCO,ZSCO);
  }
  code "26" {
    MOV(p0,p1); MOVI(p1,0);
    SR(p0); SR(p0); SR(p0); SR(p0); SR(p0); SR(p0); SR(p0); SR(p0);
    SR(p0); SR(p0);
    MSR(ZSCO,ZSCO);
  }
  code "27" {
    MOV(p0,p1); MOVI(p1,0);
    SR(p0); SR(p0); SR(p0); SR(p0); SR(p0); SR(p0); SR(p0); SR(p0);
    SR(p0); SR(p0); SR(p0);
    MSR(ZSCO,ZSCO);
  }
  code "28" {
    MOV(p0,p1); MOVI(p1,0);
    SR(p0); SR(p0); SR(p0); SR(p0); SR(p0); SR(p0); SR(p0); SR(p0);
    SR(p0); SR(p0); SR(p0); SR(p0);
    MSR(ZSCO,ZSCO);
  }
  code "29" {
    MOV(p0,p1); MOVI(p1,0);
    SR(p0); SR(p0); SR(p0); SR(p0); SR(p0); SR(p0); SR(p0); SR(p0);
    SR(p0); SR(p0); SR(p0); SR(p0); SR(p0);
    MSR(ZSCO,ZSCO);
  }
  code "30" {
    MOV(p0,p1); MOVI(p1,0);
    SR(p0); SR(p0); SR(p0); SR(p0); SR(p0); SR(p0); SR(p0); SR(p0);
    SR(p0); SR(p0); SR(p0); SR(p0); SR(p0); SR(p0);
    MSR(ZSCO,ZSCO);
  }
  code "31" {
    MOV(p0,p1); MOVI(p1,0);
    SR(p0); SR(p0); SR(p0); SR(p0); SR(p0); SR(p0); SR(p0); SR(p0);
    SR(p0); SR(p0); SR(p0); SR(p0); SR(p0); SR(p0); SR(p0);
    MSR(ZSCO,ZSCO);
  }
  code "32" {
    SL(p1); MOVI(p0,0); MOVI(p1,0);
    MSS(Z); MSC(SO); MSR(ZSCO,ZSCO);
  }
}

instruction SHR.D "$R, $m" {
  UL; $LogicalShiftRight32(A);
}

################################################################################
## SRA <register>, <value>
##
## Cycles: 5+
## ZSCO: XXX0
##
## Variants:
##    SRA.W <reg>, <reg>
##    SRA.W <reg>, <1..16>
##    SRA.D <dreg>, <reg>
##    SRA.D <dreg>, <1..32>
##
## Arithmetic shift right of the register by the specified number of bits.  The
## last bit shifted out sets the value of the "C" flag.
################################################################################

macro(bits:5) ArithmeticShiftRight16(p) {
  code "$r" {
    # Shift zero bits?
    CMP(m,C0);
    JC(Z,@zero);

    # Shift > 16 bits?
    MOVI(C2,16);
    CMP(C2,m);
    JC(S,@max);

    # Shift 1-16 bits
    MOV(C2,m);
  @shift:
    SRA(p);
    JD(C2,@shift);
    MSR(ZSCO,ZSCO);
    END;

  @max:
    CMP(p,C0);
    JC(S,@signed_max);
    MOVI(p,0);
    MSC(SCO); MSS(Z); MSR(SCO,Z);
    END;

  @signed_max:
    MOVI(p,-1);
    MSC(ZO); MSS(SC); MSR(ZO,SC);
    END;

  @zero:
    CMP(p,C0); MSR(ZSCO,ZSCO);
  }

  code "1" {
    SRA(p);
    MSR(ZSCO,ZSCO);
  }
  code "2" {
    SRA(p); SRA(p);
    MSR(ZSCO,ZSCO);
  }
  code "3" {
    SRA(p); SRA(p); SRA(p);
    MSR(ZSCO,ZSCO);
  }
  code "4" {
    SRA(p); SRA(p); SRA(p); SRA(p);
    MSR(ZSCO,ZSCO);
  }
  code "5" {
    SRA(p); SRA(p); SRA(p); SRA(p); SRA(p);
    MSR(ZSCO,ZSCO);
  }
  code "6" {
    SRA(p); SRA(p); SRA(p); SRA(p); SRA(p); SRA(p);
    MSR(ZSCO,ZSCO);
  }
  code "7" {
    SRA(p); SRA(p); SRA(p); SRA(p); SRA(p); SRA(p); SRA(p);
    MSR(ZSCO,ZSCO);
  }
  code "8" {
    SRA(p); SRA(p); SRA(p); SRA(p); SRA(p); SRA(p); SRA(p); SRA(p);
    MSR(ZSCO,ZSCO);
  }
  code "9" {
    SRA(p); SRA(p); SRA(p); SRA(p); SRA(p); SRA(p); SRA(p); SRA(p);
    SRA(p);
    MSR(ZSCO,ZSCO);
  }
  code "10" {
    SRA(p); SRA(p); SRA(p); SRA(p); SRA(p); SRA(p); SRA(p); SRA(p);
    SRA(p); SRA(p);
    MSR(ZSCO,ZSCO);
  }
  code "11" {
    SRA(p); SRA(p); SRA(p); SRA(p); SRA(p); SRA(p); SRA(p); SRA(p);
    SRA(p); SRA(p); SRA(p);
    MSR(ZSCO,ZSCO);
  }
  code "12" {
    SRA(p); SRA(p); SRA(p); SRA(p); SRA(p); SRA(p); SRA(p); SRA(p);
    SRA(p); SRA(p); SRA(p); SRA(p);
    MSR(ZSCO,ZSCO);
  }
  code "13" {
    SRA(p); SRA(p); SRA(p); SRA(p); SRA(p); SRA(p); SRA(p); SRA(p);
    SRA(p); SRA(p); SRA(p); SRA(p); SRA(p);
    MSR(ZSCO,ZSCO);
  }
  code "14" {
    SRA(p); SRA(p); SRA(p); SRA(p); SRA(p); SRA(p); SRA(p); SRA(p);
    SRA(p); SRA(p); SRA(p); SRA(p); SRA(p); SRA(p);
    MSR(ZSCO,ZSCO);
  }
  code "15" {
    SRA(p); SRA(p); SRA(p); SRA(p); SRA(p); SRA(p); SRA(p); SRA(p);
    SRA(p); SRA(p); SRA(p); SRA(p); SRA(p); SRA(p); SRA(p);
    MSR(ZSCO,ZSCO);
  }
  code "16" {
    SL(p); 
    JC(C,@negative);
    MOVI(p,0);
    MSS(Z); MSC(S); MSR(ZSCO,ZSCO);
    END;
  @negative:
    MOVI(p,-1);
    MSS(S); MSC(Z); MSR(ZSCO,ZSCO);
  }
}

instruction SRA.W "$r, $m" {
  UL; $ArithmeticShiftRight16(a);
}

macro(bits:6) ArithmeticShiftRight32(P) {
  code "$r" {
    # Shift zero bits?
    CMP(m,C0);
    JC(Z,@zero);

    # Shift > 32 bits?
    MOVI(C2,32);
    CMP(C2,m);
    JC(S,@max);

    # Shift 1-32 bits
    MOV(C2,m);
  @shift:
    SRA(p1); MSR(ZS,ZS); RRC(p0);
    JD(C2,@shift);
    MSR(ZCO,CO);
    END;

  @max:
    CMP(p1,C0);
    JC(S,@signed_max);
    MOVI(p0,0); MOVI(p1,0);
    MSC(SCO); MSS(Z); MSR(SCO,Z);
    END;

  @signed_max:
    MOVI(p0,-1); MOVI(p1,-1);
    MSC(ZO); MSS(SC); MSR(ZO,SC);
    END;

  @zero:
    CMP(p0,C0); MSR(Z,Z); CMP(p1,C0); MSR(ZCSO,CSO);
  }

  code "1" {
    SRA(p1); MSR(ZS,ZS); RRC(p0);
    MSR(ZCO,CO);
  }
  code "2" {
    SRA(p1); RRC(p0);
    SRA(p1); MSR(ZS,ZS); RRC(p0);
    MSR(ZCO,CO);
  }
  code "3" {
    SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); MSR(ZS,ZS); RRC(p0);
    MSR(ZCO,CO);
  }
  code "4" {
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); MSR(ZS,ZS); RRC(p0);
    MSR(ZCO,CO);
  }
  code "5" {
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); MSR(ZS,ZS); RRC(p0);
    MSR(ZCO,CO);
  }
  code "6" {
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); RRC(p0);
    SRA(p1); MSR(ZS,ZS); RRC(p0);
    MSR(ZCO,CO);
  }
  code "7" {
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); MSR(ZS,ZS); RRC(p0);
    MSR(ZCO,CO);
  }
  code "8" {
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); MSR(ZS,ZS); RRC(p0);
    MSR(ZCO,CO);
  }
  code "9" {
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); MSR(ZS,ZS); RRC(p0);
    MSR(ZCO,CO);
  }
  code "10" {
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); RRC(p0);
    SRA(p1); MSR(ZS,ZS); RRC(p0);
    MSR(ZCO,CO);
  }
  code "11" {
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); MSR(ZS,ZS); RRC(p0);
    MSR(ZCO,CO);
  }
  code "12" {
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); MSR(ZS,ZS); RRC(p0);
    MSR(ZCO,CO);
  }
  code "13" {
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); MSR(ZS,ZS); RRC(p0);
    MSR(ZCO,CO);
  }
  code "14" {
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); RRC(p0);
    SRA(p1); MSR(ZS,ZS); RRC(p0);
    MSR(ZCO,CO);
  }
  code "15" {
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); MSR(ZS,ZS); RRC(p0);
    MSR(ZCO,CO);
  }
  code "16" {
    SL(p0); MSR(C,C); MOV(p0,p1); 
    CMP(p0,C0);
    JC(S,@negative);
    MOVI(p1,0);
    CMP(p0,C0); MSC(S); MSR(ZSO,ZSO);
    END;
  @negative:
    MOVI(p1,-1);
    MSC(ZO); MSS(S); MSR(ZSO,ZSO);
  }
  code "17" {
    MOV(p0,p1); 
    CMP(p1,C0); JC(S,@negative);
    MOVI(p1,0); JP(@shift);
  @negative:
    MOVI(p1,-1);
  @shift:
    SRA(p1); MSR(ZS,ZS); RRC(p0);
    MSR(ZCO,CO);
  }
  code "18" {
    MOV(p0,p1); 
    CMP(p1,C0); JC(S,@negative);
    MOVI(p1,0); JP(@shift);
  @negative:
    MOVI(p1,-1);
  @shift:
    SRA(p1); RRC(p0);
    SRA(p1); MSR(ZS,ZS); RRC(p0);
    MSR(ZCO,CO);
  }
  code "19" {
    MOV(p0,p1); 
    CMP(p1,C0); JC(S,@negative);
    MOVI(p1,0); JP(@shift);
  @negative:
    MOVI(p1,-1);
  @shift:
    SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); MSR(ZS,ZS); RRC(p0);
    MSR(ZCO,CO);
  }
  code "20" {
    MOV(p0,p1); 
    CMP(p1,C0); JC(S,@negative);
    MOVI(p1,0); JP(@shift);
  @negative:
    MOVI(p1,-1);
  @shift:
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); MSR(ZS,ZS); RRC(p0);
    MSR(ZCO,CO);
  }
  code "21" {
    MOV(p0,p1); 
    CMP(p1,C0); JC(S,@negative);
    MOVI(p1,0); JP(@shift);
  @negative:
    MOVI(p1,-1);
  @shift:
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); MSR(ZS,ZS); RRC(p0);
    MSR(ZCO,CO);
  }
  code "22" {
    MOV(p0,p1); 
    CMP(p1,C0); JC(S,@negative);
    MOVI(p1,0); JP(@shift);
  @negative:
    MOVI(p1,-1);
  @shift:
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); RRC(p0);
    SRA(p1); MSR(ZS,ZS); RRC(p0);
    MSR(ZCO,CO);
  }
  code "23" {
    MOV(p0,p1); 
    CMP(p1,C0); JC(S,@negative);
    MOVI(p1,0); JP(@shift);
  @negative:
    MOVI(p1,-1);
  @shift:
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); MSR(ZS,ZS); RRC(p0);
    MSR(ZCO,CO);
  }
  code "24" {
    MOV(p0,p1); 
    CMP(p1,C0); JC(S,@negative);
    MOVI(p1,0); JP(@shift);
  @negative:
    MOVI(p1,-1);
  @shift:
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); MSR(ZS,ZS); RRC(p0);
    MSR(ZCO,CO);
  }
  code "25" {
    MOV(p0,p1); 
    CMP(p1,C0); JC(S,@negative);
    MOVI(p1,0); JP(@shift);
  @negative:
    MOVI(p1,-1);
  @shift:
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
   
    SRA(p1); MSR(ZS,ZS); RRC(p0);
    MSR(ZCO,CO);
  }
  code "26" {
    MOV(p0,p1); 
    CMP(p1,C0); JC(S,@negative);
    MOVI(p1,0); JP(@shift);
  @negative:
    MOVI(p1,-1);
  @shift:
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); RRC(p0);
    SRA(p1); MSR(ZS,ZS); RRC(p0);
    MSR(ZCO,CO);
  }
  code "27" {
    MOV(p0,p1); 
    CMP(p1,C0); JC(S,@negative);
    MOVI(p1,0); JP(@shift);
  @negative:
    MOVI(p1,-1);
  @shift:
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); MSR(ZS,ZS); RRC(p0);
    MSR(ZCO,CO);
  }
  code "28" {
    MOV(p0,p1); 
    CMP(p1,C0); JC(S,@negative);
    MOVI(p1,0); JP(@shift);
  @negative:
    MOVI(p1,-1);
  @shift:
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); MSR(ZS,ZS); RRC(p0);
    MSR(ZCO,CO);
  }
  code "29" {
    MOV(p0,p1); 
    CMP(p1,C0); JC(S,@negative);
    MOVI(p1,0); JP(@shift);
  @negative:
    MOVI(p1,-1);
  @shift:
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); MSR(ZS,ZS); RRC(p0);
    MSR(ZCO,CO);
  }
  code "30" {
    MOV(p0,p1); 
    CMP(p1,C0); JC(S,@negative);
    MOVI(p1,0); JP(@shift);
  @negative:
    MOVI(p1,-1);
  @shift:
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); RRC(p0);
    SRA(p1); MSR(ZS,ZS); RRC(p0);
    MSR(ZCO,CO);
  }
  code "31" {
    MOV(p0,p1); 
    CMP(p1,C0); JC(S,@negative);
    MOVI(p1,0); JP(@shift);
  @negative:
    MOVI(p1,-1);
  @shift:
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); RRC(p0); SRA(p1); RRC(p0);
    SRA(p1); MSR(ZS,ZS); RRC(p0);
    MSR(ZCO,CO);
  }
  code "32" {
    SL(p1);
    JC(C,@negative);
    MOVI(p0,0); MOVI(p1,0);
    MSC(SCO); MSS(Z); MSR(SCO,Z);
  @negative:
    MOVI(p0,-1); MOVI(p1,-1);
    MSC(ZO); MSS(SC); MSR(ZO,SC);
  }
}

instruction SRA.D "$R, $m" {
  UL; $ArithmeticShiftRight32(A);
}

################################################################################
## ROL <register>, <value>
##
## Cycles: 5+
## ZSCO: XXX0
##
## Variants:
##    ROL.W <reg>, <reg>
##    ROL.W <reg>, <1..16>
##    ROL.D <dreg>, <reg>
##    ROL.D <dreg>, <1..32>
##
## Rotate left of the register by the specified number of bits. The last bit
## shifted sets the value of the "C" flag.
################################################################################

macro(bits:5) RotateLeft16(p) {
  code "$r" {
    # Rotate zero bits?
    CMP(m,C0);
    JC(Z,@zero);

    # Rotate modulo 16 bits?
    MOVI(C2,15);
    AND(C2,m);
    JC(Z,@sixteen);

    # Rotate 1-15 bits
  @shift:
    RL(p);
    JD(C2,@shift);
    MSR(ZSCO,ZSCO);
    END;

  @sixteen:
    MOV(C2,p);
    SR(C2); MSR(C,C);
    CMP(p,C0);
    MSR(ZSO,ZSO);
    END;

  @zero:
    CMP(p,C0); MSR(ZSCO,ZSCO);
  }

  code "1" {
    RL(p);
    MSR(ZSCO,ZSCO);
  }
  code "2" {
    RL(p); RL(p);
    MSR(ZSCO,ZSCO);
  }
  code "3" {
    RL(p); RL(p); RL(p);
    MSR(ZSCO,ZSCO);
  }
  code "4" {
    RL(p); RL(p); RL(p); RL(p);
    MSR(ZSCO,ZSCO);
  }
  code "5" {
    RL(p); RL(p); RL(p); RL(p); RL(p);
    MSR(ZSCO,ZSCO);
  }
  code "6" {
    RL(p); RL(p); RL(p); RL(p); RL(p); RL(p);
    MSR(ZSCO,ZSCO);
  }
  code "7" {
    RL(p); RL(p); RL(p); RL(p); RL(p); RL(p); RL(p);
    MSR(ZSCO,ZSCO);
  }
  code "8" {
    RL(p); RL(p); RL(p); RL(p); RL(p); RL(p); RL(p); RL(p);
    MSR(ZSCO,ZSCO);
  }
  code "9" {
    RL(p); RL(p); RL(p); RL(p); RL(p); RL(p); RL(p); RL(p);
    RL(p);
    MSR(ZSCO,ZSCO);
  }
  code "10" {
    RL(p); RL(p); RL(p); RL(p); RL(p); RL(p); RL(p); RL(p);
    RL(p); RL(p);
    MSR(ZSCO,ZSCO);
  }
  code "11" {
    RL(p); RL(p); RL(p); RL(p); RL(p); RL(p); RL(p); RL(p);
    RL(p); RL(p); RL(p);
    MSR(ZSCO,ZSCO);
  }
  code "12" {
    RL(p); RL(p); RL(p); RL(p); RL(p); RL(p); RL(p); RL(p);
    RL(p); RL(p); RL(p); RL(p);
    MSR(ZSCO,ZSCO);
  }
  code "13" {
    RL(p); RL(p); RL(p); RL(p); RL(p); RL(p); RL(p); RL(p);
    RL(p); RL(p); RL(p); RL(p); RL(p);
    MSR(ZSCO,ZSCO);
  }
  code "14" {
    RL(p); RL(p); RL(p); RL(p); RL(p); RL(p); RL(p); RL(p);
    RL(p); RL(p); RL(p); RL(p); RL(p); RL(p);
    MSR(ZSCO,ZSCO);
  }
  code "15" {
    RL(p); RL(p); RL(p); RL(p); RL(p); RL(p); RL(p); RL(p);
    RL(p); RL(p); RL(p); RL(p); RL(p); RL(p); RL(p);
    MSR(ZSCO,ZSCO);
  }
  code "16" {
    MOV(C2,p);
    SR(C2); MSR(C,C);
    CMP(p,C0);
    MSR(ZSO,ZSO);
  }
}

instruction ROL.W "$r, $m" {
  UL; $RotateLeft16(a);
}

macro(bits:6) GetRotateCount32:r {
  code:m "$r" {}
  code:C1 "1" { MOVI(C1,1); }
  code:C1 "2" { MOVI(C1,2); }
  code:C1 "3" { MOVI(C1,3); }
  code:C1 "4" { MOVI(C1,4); }
  code:C1 "5" { MOVI(C1,5); }
  code:C1 "6" { MOVI(C1,6); }
  code:C1 "7" { MOVI(C1,7); }
  code:C1 "8" { MOVI(C1,8); }
  code:C1 "9" { MOVI(C1,9); }
  code:C1 "10" { MOVI(C1,10); }
  code:C1 "11" { MOVI(C1,11); }
  code:C1 "12" { MOVI(C1,12); }
  code:C1 "13" { MOVI(C1,13); }
  code:C1 "14" { MOVI(C1,14); }
  code:C1 "15" { MOVI(C1,15); }
  code:C1 "16" { MOVI(C1,16); }
  code:C1 "17" { MOVI(C1,17); }
  code:C1 "18" { MOVI(C1,18); }
  code:C1 "19" { MOVI(C1,19); }
  code:C1 "20" { MOVI(C1,20); }
  code:C1 "21" { MOVI(C1,21); }
  code:C1 "22" { MOVI(C1,22); }
  code:C1 "23" { MOVI(C1,23); }
  code:C1 "24" { MOVI(C1,24); }
  code:C1 "25" { MOVI(C1,25); }
  code:C1 "26" { MOVI(C1,26); }
  code:C1 "27" { MOVI(C1,27); }
  code:C1 "28" { MOVI(C1,28); }
  code:C1 "29" { MOVI(C1,29); }
  code:C1 "30" { MOVI(C1,30); }
  code:C1 "31" { MOVI(C1,31); }
  code:C1 "32" { MOVI(C1,32); }
}

instruction ROL.D "$R, $m" {
  UL;
  $GetRotateCount32;

  # Rotate zero bits?
  CMP(r,C0);
  JC(Z,@zero);

  # Rotate modulo 32 bits?
  MOVI(C2,31);
  AND(C2,r);
  JC(Z,@thirtytwo);

  # Rotate 1-31 bits
  MOVI(C1,1); RR(C1); 
@shift:
  MOV(C0,C1); AND(C0,a1); RL(C0);
  RLC(a0); MSR(Z,Z); RLC(a1);
  JD(C2,@shift);
  MSR(ZSCO,SCO);
  END;

@thirtytwo:
  MOV(C2,a0);
  SR(C2); MSR(C,C);
  CMP(a0,C0); MSR(Z,Z);
  CMP(a1,C0); MSR(ZSO,SO);
  END;

@zero:
  CMP(a0,C0); MSR(Z,Z); CMP(a1,C0); MSR(ZCSO,CSO);
}

################################################################################
## ROR <register>, <value>
##
## Cycles: 5+
## ZSCO: XXX0
##
## Variants:
##    ROR.W <reg>, <reg>
##    ROR.W <reg>, <1..16>
##    ROR.D <dreg>, <reg>
##    ROR.D <dreg>, <1..32>
##
## Rotate right of the register by the specified number of bits. The last bit
## shifted sets the value of the "C" flag.
################################################################################

macro(bits:5) RotateRight16(p) {
  code "$r" {
    # Rotate zero bits?
    CMP(m,C0);
    JC(Z,@zero);

    # Rotate modulo 16 bits?
    MOVI(C2,15);
    AND(C2,m);
    JC(Z,@sixteen);

    # Rotate 1-15 bits
  @shift:
    RR(p);
    JD(C2,@shift);
    MSR(ZSCO,ZSCO);
    END;

  @sixteen:
    MOV(C2,p);
    SL(C2); MSR(C,C);
    CMP(p,C0);
    MSR(ZSO,ZSO);
    END;

  @zero:
    CMP(p,C0); MSR(ZSCO,ZSCO);
  }

  code "1" {
    RR(p);
    MSR(ZSCO,ZSCO);
  }
  code "2" {
    RR(p); RR(p);
    MSR(ZSCO,ZSCO);
  }
  code "3" {
    RR(p); RR(p); RR(p);
    MSR(ZSCO,ZSCO);
  }
  code "4" {
    RR(p); RR(p); RR(p); RR(p);
    MSR(ZSCO,ZSCO);
  }
  code "5" {
    RR(p); RR(p); RR(p); RR(p); RR(p);
    MSR(ZSCO,ZSCO);
  }
  code "6" {
    RR(p); RR(p); RR(p); RR(p); RR(p); RR(p);
    MSR(ZSCO,ZSCO);
  }
  code "7" {
    RR(p); RR(p); RR(p); RR(p); RR(p); RR(p); RR(p);
    MSR(ZSCO,ZSCO);
  }
  code "8" {
    RR(p); RR(p); RR(p); RR(p); RR(p); RR(p); RR(p); RR(p);
    MSR(ZSCO,ZSCO);
  }
  code "9" {
    RR(p); RR(p); RR(p); RR(p); RR(p); RR(p); RR(p); RR(p);
    RR(p);
    MSR(ZSCO,ZSCO);
  }
  code "10" {
    RR(p); RR(p); RR(p); RR(p); RR(p); RR(p); RR(p); RR(p);
    RR(p); RR(p);
    MSR(ZSCO,ZSCO);
  }
  code "11" {
    RR(p); RR(p); RR(p); RR(p); RR(p); RR(p); RR(p); RR(p);
    RR(p); RR(p); RR(p);
    MSR(ZSCO,ZSCO);
  }
  code "12" {
    RR(p); RR(p); RR(p); RR(p); RR(p); RR(p); RR(p); RR(p);
    RR(p); RR(p); RR(p); RR(p);
    MSR(ZSCO,ZSCO);
  }
  code "13" {
    RR(p); RR(p); RR(p); RR(p); RR(p); RR(p); RR(p); RR(p);
    RR(p); RR(p); RR(p); RR(p); RR(p);
    MSR(ZSCO,ZSCO);
  }
  code "14" {
    RR(p); RR(p); RR(p); RR(p); RR(p); RR(p); RR(p); RR(p);
    RR(p); RR(p); RR(p); RR(p); RR(p); RR(p);
    MSR(ZSCO,ZSCO);
  }
  code "15" {
    RR(p); RR(p); RR(p); RR(p); RR(p); RR(p); RR(p); RR(p);
    RR(p); RR(p); RR(p); RR(p); RR(p); RR(p); RR(p);
    MSR(ZSCO,ZSCO);
  }
  code "16" {
    MOV(C2,p);
    SR(C2); MSR(C,C);
    CMP(p,C0);
    MSR(ZSO,ZSO);
  }
}

instruction ROR.W "$r, $m" {
  UL; $RotateRight16(a);
}

instruction ROR.D "$R, $m" {
  UL;
  $GetRotateCount32;

  # Rotate zero bits?
  CMP(r,C0);
  JC(Z,@zero);

  # Rotate modulo 32 bits?
  MOVI(C2,31);
  AND(C2,r);
  JC(Z,@thirtytwo);

  # Rotate 1-31 bits
@shift:
  MOVI(C0,1); AND(C0,a0); RR(C0);
  RRC(a1); MSR(ZS,ZS); RRC(a0);
  JD(C2,@shift);
  MSR(ZCO,CO);
  END;

@thirtytwo:
  MOV(C2,a0);
  SR(C2); MSR(C,C);
  CMP(a0,C0); MSR(Z,Z);
  CMP(a1,C0); MSR(ZSO,SO);
  END;

@zero:
  CMP(a0,C0); MSR(Z,Z); CMP(a1,C0); MSR(ZCSO,CSO);
}

################################################################################
## RLC <register>, <value>
##
## Cycles: 5+
## ZSCO: XXX0
##
## Variants:
##    RLC.W <reg>, <reg>
##    RLC.W <reg>, <1..16>
##    RLC.D <dreg>, <reg>
##    RLC.D <dreg>, <1..32>
##
## Rotate left of the register through the "C" flag by the specified number of
## bits. The last bit shifted sets the value of the "C" flag.
################################################################################

macro(bits:5) RotateLeft16ThroughCarry(p) {
  code "$r" {
    # Rotate zero bits?
    CMP(m,C0);
    JC(Z,@zero);

    # TODO: Modulo rotate 17 if it is too big.

    # Rotate 1+ bits
  @shift:
    RLC(p);
    JD(C2,@shift);
    MSR(ZSCO,ZSCO);
    END;

  @zero:
    CMP(p,C0); MSR(ZSCO,ZSCO);
  }

  code "1" {
    RLC(p);
    MSR(ZSCO,ZSCO);
  }
  code "2" {
    RLC(p); RLC(p);
    MSR(ZSCO,ZSCO);
  }
  code "3" {
    RLC(p); RLC(p); RLC(p);
    MSR(ZSCO,ZSCO);
  }
  code "4" {
    RLC(p); RLC(p); RLC(p); RLC(p);
    MSR(ZSCO,ZSCO);
  }
  code "5" {
    RLC(p); RLC(p); RLC(p); RLC(p); RLC(p);
    MSR(ZSCO,ZSCO);
  }
  code "6" {
    RLC(p); RLC(p); RLC(p); RLC(p); RLC(p); RLC(p);
    MSR(ZSCO,ZSCO);
  }
  code "7" {
    RLC(p); RLC(p); RLC(p); RLC(p); RLC(p); RLC(p); RLC(p);
    MSR(ZSCO,ZSCO);
  }
  code "8" {
    RLC(p); RLC(p); RLC(p); RLC(p); RLC(p); RLC(p); RLC(p); RLC(p);
    MSR(ZSCO,ZSCO);
  }
  code "9" {
    RLC(p); RLC(p); RLC(p); RLC(p); RLC(p); RLC(p); RLC(p); RLC(p);
    RLC(p);
    MSR(ZSCO,ZSCO);
  }
  code "10" {
    RLC(p); RLC(p); RLC(p); RLC(p); RLC(p); RLC(p); RLC(p); RLC(p);
    RLC(p); RLC(p);
    MSR(ZSCO,ZSCO);
  }
  code "11" {
    RLC(p); RLC(p); RLC(p); RLC(p); RLC(p); RLC(p); RLC(p); RLC(p);
    RLC(p); RLC(p); RLC(p);
    MSR(ZSCO,ZSCO);
  }
  code "12" {
    RLC(p); RLC(p); RLC(p); RLC(p); RLC(p); RLC(p); RLC(p); RLC(p);
    RLC(p); RLC(p); RLC(p); RLC(p);
    MSR(ZSCO,ZSCO);
  }
  code "13" {
    RLC(p); RLC(p); RLC(p); RLC(p); RLC(p); RLC(p); RLC(p); RLC(p);
    RLC(p); RLC(p); RLC(p); RLC(p); RLC(p);
    MSR(ZSCO,ZSCO);
  }
  code "14" {
    RLC(p); RLC(p); RLC(p); RLC(p); RLC(p); RLC(p); RLC(p); RLC(p);
    RLC(p); RLC(p); RLC(p); RLC(p); RLC(p); RLC(p);
    MSR(ZSCO,ZSCO);
  }
  code "15" {
    RLC(p); RLC(p); RLC(p); RLC(p); RLC(p); RLC(p); RLC(p); RLC(p);
    RLC(p); RLC(p); RLC(p); RLC(p); RLC(p); RLC(p); RLC(p);
    MSR(ZSCO,ZSCO);
  }
  code "16" {
    RLC(p); RLC(p); RLC(p); RLC(p); RLC(p); RLC(p); RLC(p); RLC(p);
    RLC(p); RLC(p); RLC(p); RLC(p); RLC(p); RLC(p); RLC(p); RLC(p);
    MSR(ZSCO,ZSCO);
  }
}

instruction RLC.W "$r, $m" {
  UL; $RotateLeft16ThroughCarry(a);
}

macro(bits:6) GetRotateCount32ThroughCarry:r {
  code:m "$r" {}
  code:C1 "1" { MOVI(C1,1); }
  code:C1 "2" { MOVI(C1,2); }
  code:C1 "3" { MOVI(C1,3); }
  code:C1 "4" { MOVI(C1,4); }
  code:C1 "5" { MOVI(C1,5); }
  code:C1 "6" { MOVI(C1,6); }
  code:C1 "7" { MOVI(C1,7); }
  code:C1 "8" { MOVI(C1,8); }
  code:C1 "9" { MOVI(C1,9); }
  code:C1 "10" { MOVI(C1,10); }
  code:C1 "11" { MOVI(C1,11); }
  code:C1 "12" { MOVI(C1,12); }
  code:C1 "13" { MOVI(C1,13); }
  code:C1 "14" { MOVI(C1,14); }
  code:C1 "15" { MOVI(C1,15); }
  code:C1 "16" { MOVI(C1,16); }
  code:C1 "17" { MOVI(C1,17); }
  code:C1 "18" { MOVI(C1,18); }
  code:C1 "19" { MOVI(C1,19); }
  code:C1 "20" { MOVI(C1,20); }
  code:C1 "21" { MOVI(C1,21); }
  code:C1 "22" { MOVI(C1,22); }
  code:C1 "23" { MOVI(C1,23); }
  code:C1 "24" { MOVI(C1,24); }
  code:C1 "25" { MOVI(C1,25); }
  code:C1 "26" { MOVI(C1,26); }
  code:C1 "27" { MOVI(C1,27); }
  code:C1 "28" { MOVI(C1,28); }
  code:C1 "29" { MOVI(C1,29); }
  code:C1 "30" { MOVI(C1,30); }
  code:C1 "31" { MOVI(C1,31); }
  code:C1 "32" { MOVI(C1,32); }
}

instruction RLC.D "$R, $m" {
  UL;
  $GetRotateCount32ThroughCarry;

  # Rotate zero bits?
  CMP(r,C0);
  JC(Z,@zero);

  # TODO: Modulo rotate 33 if it is too big.

  # Rotate 1+ bits
@shift:
  RLC(a0); MSR(Z,Z); RLC(a1);
  JD(C2,@shift);
  MSR(ZSCO,SCO);
  END;

@zero:
  CMP(a0,C0); MSR(Z,Z); CMP(a1,C0); MSR(ZCSO,CSO);
}

################################################################################
## RRC <register>, <value>
##
## Cycles: 5+
## ZSCO: XXX0
##
## Variants:
##    RRC.W <reg>, <reg>
##    RRC.W <reg>, <1..16>
##    RRC.D <dreg>, <reg>
##    RRC.D <dreg>, <1..32>
##
## Rotate right of the register through the "C" flag by the specified number of
## bits. The last bit shifted sets the value of the "C" flag.
################################################################################

macro(bits:5) RotateRight16ThroughCarry(p) {
  code "$r" {
    # Rotate zero bits?
    CMP(m,C0);
    JC(Z,@zero);

    # TODO: Modulo rotate 17 if it is too big.

    # Rotate 1+ bits
  @shift:
    RRC(p);
    JD(C2,@shift);
    MSR(ZSCO,ZSCO);
    END;

  @zero:
    CMP(p,C0); MSR(ZSCO,ZSCO);
  }

  code "1" {
    RRC(p);
    MSR(ZSCO,ZSCO);
  }
  code "2" {
    RRC(p); RRC(p);
    MSR(ZSCO,ZSCO);
  }
  code "3" {
    RRC(p); RRC(p); RRC(p);
    MSR(ZSCO,ZSCO);
  }
  code "4" {
    RRC(p); RRC(p); RRC(p); RRC(p);
    MSR(ZSCO,ZSCO);
  }
  code "5" {
    RRC(p); RRC(p); RRC(p); RRC(p); RRC(p);
    MSR(ZSCO,ZSCO);
  }
  code "6" {
    RRC(p); RRC(p); RRC(p); RRC(p); RRC(p); RRC(p);
    MSR(ZSCO,ZSCO);
  }
  code "7" {
    RRC(p); RRC(p); RRC(p); RRC(p); RRC(p); RRC(p); RRC(p);
    MSR(ZSCO,ZSCO);
  }
  code "8" {
    RRC(p); RRC(p); RRC(p); RRC(p); RRC(p); RRC(p); RRC(p); RRC(p);
    MSR(ZSCO,ZSCO);
  }
  code "9" {
    RRC(p); RRC(p); RRC(p); RRC(p); RRC(p); RRC(p); RRC(p); RRC(p);
    RRC(p);
    MSR(ZSCO,ZSCO);
  }
  code "10" {
    RRC(p); RRC(p); RRC(p); RRC(p); RRC(p); RRC(p); RRC(p); RRC(p);
    RRC(p); RRC(p);
    MSR(ZSCO,ZSCO);
  }
  code "11" {
    RRC(p); RRC(p); RRC(p); RRC(p); RRC(p); RRC(p); RRC(p); RRC(p);
    RRC(p); RRC(p); RRC(p);
    MSR(ZSCO,ZSCO);
  }
  code "12" {
    RRC(p); RRC(p); RRC(p); RRC(p); RRC(p); RRC(p); RRC(p); RRC(p);
    RRC(p); RRC(p); RRC(p); RRC(p);
    MSR(ZSCO,ZSCO);
  }
  code "13" {
    RRC(p); RRC(p); RRC(p); RRC(p); RRC(p); RRC(p); RRC(p); RRC(p);
    RRC(p); RRC(p); RRC(p); RRC(p); RRC(p);
    MSR(ZSCO,ZSCO);
  }
  code "14" {
    RRC(p); RRC(p); RRC(p); RRC(p); RRC(p); RRC(p); RRC(p); RRC(p);
    RRC(p); RRC(p); RRC(p); RRC(p); RRC(p); RRC(p);
    MSR(ZSCO,ZSCO);
  }
  code "15" {
    RRC(p); RRC(p); RRC(p); RRC(p); RRC(p); RRC(p); RRC(p); RRC(p);
    RRC(p); RRC(p); RRC(p); RRC(p); RRC(p); RRC(p); RRC(p);
    MSR(ZSCO,ZSCO);
  }
  code "16" {
    RRC(p); RRC(p); RRC(p); RRC(p); RRC(p); RRC(p); RRC(p); RRC(p);
    RRC(p); RRC(p); RRC(p); RRC(p); RRC(p); RRC(p); RRC(p); RRC(p);
    MSR(ZSCO,ZSCO);
  }
}

instruction RRC.W "$r, $m" {
  UL; $RotateRight16ThroughCarry(a);
}

instruction RRC.D "$R, $m" {
  UL;
  $GetRotateCount32ThroughCarry;

  # Rotate zero bits?
  CMP(r,C0);
  JC(Z,@zero);

  # TODO: Modulo rotate 33 if it is too big.

  # Rotate 1+ bits
@shift:
  RRC(a1); MSR(ZS,ZS); RRC(a0);
  JD(C2,@shift);
  MSR(ZCO,CO);
  END;

@zero:
  CMP(a0,C0); MSR(Z,Z); CMP(a1,C0); MSR(ZCSO,CSO);
}

################################################################################
## CLRB <register>, <bit-position>
##
## Cycles: 6+
## ZSCO: ----
##
## Variants:
##    CLRB.W <reg>, <word-value>
##    CLRB.D <dreg>, <dword-value>
##
## Clears bit in the specified register.
################################################################################

instruction CLRB.W "$r, $m" {
  $Get16BitMask;
  NOT(r,r);
  AND(a,r);
}

instruction CLRB.D "$R, $m" {
  $Get32BitMask;
  NOT(r0,r0);
  NOT(r1,r1);
  AND(a0,r0);
  AND(a1,r1);
}

################################################################################
## SETB <register>, <bit-position>
##
## Cycles: 5+
## ZSCO: ----
##
## Variants:
##    SETB.W <reg>, <word-value>
##    SETB.D <dreg>, <dword-value>
##
## Sets bit in the specified register.
################################################################################

instruction SETB.W "$r, $m" {
  $Get16BitMask;
  OR(a,r);
}

instruction SETB.D "$R, $m" {
  $Get32BitMask;
  OR(a0,r0);
  OR(a1,r1);
}

################################################################################
## NOTB <register>, <bit-position>
##
## Cycles: 5+
## ZSCO: ----
##
## Variants:
##    NOTB.W <reg>, <word-value>
##    NOTB.D <dreg>, <dword-value>
##
## Toggles bit in the specified register.
################################################################################

instruction NOTB.W "$r, $m" {
  $Get16BitMask;
  XOR(a,r);
}

instruction NOTB.D "$R, $m" {
  $Get32BitMask;
  XOR(a0,r0);
  XOR(a1,r1);
}

################################################################################
## TSTB <register>, <bit-position>
##
## Cycles: 5+
## ZSCO: X---
##
## Variants:
##    TSTB.W <reg>, <word-value>
##    TSTB.D <dreg>, <dword-value>
##
## Tests a bit in the specified register, setting Z if it is zero.
################################################################################

instruction TSTB.W "$r, $m" {
  $Get16BitMask;
  AND(r,a);
  MSR(Z,Z);
}

instruction TSTB.D "$R, $m" {
  $Get32BitMask;
  AND(r0,a0);
  MSR(Z,Z);
  AND(r1,a1);
  MSR(Z,_);
}

################################################################################
## CLRF <flags>
##
## Cycles: 3
## ZSCO: ????
##
## Clears the specified status flags.
################################################################################

instruction CLRF "$#4" {
  MSC(a); MSR(a,_); UL;
}

################################################################################
## SETF <flags>
##
## Cycles: 3
## ZSCO: ????
##
## Sets the specified status flags.
################################################################################

instruction SETF "$#4" {
  MSS(a); MSR(_,a); UL;
}

################################################################################
## NOTF <flags>
##
## Cycles: 3
## ZSCO: ????
##
## Performs a bitwise NOT to the specified status flags.
################################################################################

instruction NOTF "$#4" {
  MSX(a); MSR(a,a); UL;
}

################################################################################
## TST <value>
##
## Cycles: 4+
## ZSCO: XX00
##
## Variants:
##    TST.W <word-value>
##    TST.D <dword-value>
##
## Tests a value setting flags.
################################################################################

instruction TST.W "$m" {
  $GetWord;
  CMP(r,C0);
  MSR(ZSCO,ZSCO);
}

instruction TST.D "$m" {
  $GetDword;
  CMP(r0,C2);
  MSR(Z,Z);
  CMP(r1,C2);
  MSR(ZSCO,_SCO);
}

################################################################################
## CMP <register> <value>
##
## Cycles: 4+
## ZSCO: XXXX
##
## Variants:
##    CMP.W <reg> <word-value>
##    CMP.D <dreg> <dword-value>
##
## Subtracts <value> from <register> setting flags, but not updating <register>.
################################################################################

instruction CMP.W "$r, $m" {
  $GetWord;
  CMP(a,r);
  MSR(ZSCO,ZSCO);
}

instruction CMP.D "$R, $m" {
  $GetDword;
  CMP(a0,r0);
  MSR(Z,Z);
  MOV(C2,a1);
  SBC(C2,r1);
  MSR(ZSCO,_SCO);
}

################################################################################
## JP <address>
##
## Cycles: 4+
## ZSCO: ----
##
## Sets IP to the specified address.
################################################################################

instruction JP "$m" {
  $GetWord;
  MOV(IP,r);
}

################################################################################
## JPR <relative-address>
##
## Cycles: 4+
## ZSCO: ----
##
## Adds the specified relative address to IP.
################################################################################

instruction JPR "$m" {
  $GetWord;
  ADD(IP,r);
}

################################################################################
## JC <condition> <address>
##
## Cycles: 3+
## ZSCO: ----
##
## Sets IP to the specified address if the specified condition is true.
################################################################################

instruction JC "$#3, $m" {
  $GetWord;
  JC(a,@jump);
  END;
@jump:
  MOV(IP,r);
}

################################################################################
## JCR <condition> <relative-address>
##
## Cycles: 3+
## ZSCO: ----
##
## Adds the specified relative address to IP if the specified condition is true.
################################################################################

instruction JCR "$#3, $m" {
  $GetWord;
  JC(a,@jump);
  END;
@jump:
  ADD(IP,r);
}

################################################################################
## CALL <address>
##
## Cycles: 6+
## ZSCO: ----
##
## Pushes IP onto the stack and sets IP to the specified address.
################################################################################

instruction CALL "$m" {
  $GetWord;
  LK(STACK); ADR(SP); STP(IP); UL;
  MOV(IP,r);
}

################################################################################
## CALLR <relative-address>
##
## Cycles: 6+
## ZSCO: ----
##
## Pushes IP onto the stack and adds the specified relative address to IP.
################################################################################

instruction CALLR "$m" {
  $GetWord;
  LK(STACK); ADR(SP); STP(IP); UL;
  ADD(IP,r);
}

################################################################################
## FBGN
##
## Cycles: 6
## ZSCO: ----
##
## Pushes FP onto the stack and sets it to SP.
################################################################################

instruction FBGN {
  UL;
  LK(STACK); ADR(SP); STP(FP); LAD(SP); UL;
  MOV(FP,SP);
}

################################################################################
## FEND
##
## Cycles: 6
## ZSCO: ----
##
## Restores SP from FP and removes FP from the stack
################################################################################

instruction FEND {
  UL;
  MOV(SP,FP);
  LK(STACK); ADR(SP); LD(FP); LAD(SP); UL;
}

################################################################################
## RET
## RET <size>
##
## Cycles: 5-6
## ZSCO: ----
##
## Variants:
##   RET
##   RET.A <size>
##
## Pops 0-31 words from the stack, then pops IP from the stack.
################################################################################

instruction RET {
  UL;
  LK(STACK); ADR(SP); LD(IP); LAD(SP); UL;
}

instruction RET.A "$#5" {
  UL;
  ADD(SP,C0);
  LK(STACK); ADR(SP); LD(IP); LAD(SP); UL;
}

################################################################################
## RETC <condition>
## RETC <condition> <size>
##
## Cycles: 3-7
## ZSCO: ----
##
## Variants:
##   RETC   <condition>
##   RETC.A <condition> <size>
##
## If the specified condition is true, optionally pops 0-31 words from the
## stack, then pops IP from the stack.
################################################################################

instruction RETC "$#3" {
  UL;
  JC(a,@return);
  END;
@return:
  LK(STACK); ADR(SP); LD(IP); LAD(SP); UL;
}

instruction RETC.A "$#3, $#5" {
  UL;
  JC(a,@return);
  END;
@return:
  ADD(SP,C1);
  LK(STACK); ADR(SP); LD(IP); LAD(SP); UL;
}

################################################################################
## IRT
## IRT <size>
##
## Cycles: 7-8
## ZSCO: ----
##
## Variants:
##   IRT
##   IRT.A <size>
##
## Pops 0-31 words from the stack, then pops ST and IP from the stack.
################################################################################

instruction IRT {
  UL;
  LK(STACK); ADR(SP); LD(ST); LD(IP); LAD(SP); UL;
  MSM(ZSCOI,ST); MSR(ZSCOI,ZSCOI);
}

instruction IRT.A "$#5" {
  UL;
  ADD(SP,C0);
  LK(STACK); ADR(SP); LD(ST); LD(IP); LAD(SP); UL;
  MSM(ZSCOI,ST); MSR(ZSCOI,ZSCOI);
}

################################################################################
## IRTC <condition>
## IRTC <condition> <size>
##
## Cycles: 3-9
## ZSCO: ----
##
## Variants:
##   IRTC   <condition>
##   IRTC.A <condition> <size>
##
## If the specified condition is true, optionally pops 0-31 words from the
## stack, then pops ST and IP from the stack.
################################################################################

instruction IRTC "$#3" {
  UL;
  JC(a,@return);
  END;
@return:
  LK(STACK); ADR(SP); LD(ST); LD(IP); LAD(SP); UL;
  MSM(ZSCOI,ST); MSR(ZSCOI,ZSCOI);
}

instruction IRTC.A "$#3, $#5" {
  UL;
  JC(a,@return);
  END;
@return:
  ADD(SP,C1);
  LK(STACK); ADR(SP); LD(ST); LD(IP); LAD(SP); UL;
  MSM(ZSCOI,ST); MSR(ZSCOI,ZSCOI);
}

################################################################################
## EI
##
## Cycles: 3
## ZSCO: ----
##
## Enables interrupts.
################################################################################

instruction EI {
  UL;
  MSS(I);
  MSR(_,I);
}

################################################################################
## DI
##
## Cycles: 3
## ZSCO: ----
##
## Disables interrupts.
################################################################################

instruction DI {
  UL;
  MSC(I);
  MSR(I,_);
}

################################################################################
## GETI <interrupt> <register>
##
## Cycles: 4+
## ZSCO: ----
##
## Retrieves the address of the specified interrupt and assigns to a register.
################################################################################

instruction GETI "$m, $r" {
  $GetWord;
  ILD(r,b);
}

################################################################################
## SETI <interrupt> <register>
##
## Cycles: 4+
## ZSCO: ----
##
## Sets the address of the specified interrupt from a register.
################################################################################

instruction SETI "$m, $r" {
  $GetWord;
  IST(r,b);
}

################################################################################
## INT <interrupt>
##
## Cycles: 4+
## ZSCO: ----
##
## Triggers the specified interrupt.
################################################################################

instruction INT "$m" {
  $GetWord;
  INT(r);
}

################################################################################
## IN <port> <dst>
##
## Cycles: 4+
## ZSCO: -X--
##
## Variants:
##    IN.RW <reg>    <reg>
##    IN.RW <reg>    <word-address>
##    IN.IW <0..255> <reg>
##    IN.IW <0..255> <word-address>
##    IN.RD <reg>    <dreg>
##    IN.RD <reg>    <dword-address>
##    IN.ID <0..255> <dreg>
##    IN.ID <0..255> <dword-address>
##
## Unconditionally reads from the specified port and writes to the specified
## register or memory address. "S" flag is set if a new word was read, otherwise
## it is cleared.
################################################################################

macro(bits:5) ReadPortWord(p) {
  code "$r" {
    UL;
    PLK(p); PLD(S,m); MSR(S,S); PUL;
  }
  code "($r)" {
    UL;
    PLK(p); PLD(S,C0); MSR(S,S); PUL;
    LKR(m); ADR(m); ST(C0); UL;
  }
  code "($r + $v)" {
    LD(C2); UL; ADD(C2,m);
    PLK(p); PLD(S,C0); MSR(S,S); PUL;
    LKR(m); ADR(C2); ST(C0); UL;
  }
  code "(SP)" {
    UL;
    PLK(p); PLD(S,C0); MSR(S,S); PUL;
    LK(STACK); ADR(SP); ST(C0); UL;
  }
  code "(SP + $v)" {
    LD(C2); UL; ADD(C2,SP);
    PLK(p); PLD(S,C0); MSR(S,S); PUL;
    LK(STACK); ADR(C2); ST(C0); UL;
  }
  code "(FP)" {
    UL;
    PLK(p); PLD(S,C0); MSR(S,S); PUL;
    LK(STACK); ADR(FP); ST(C0); UL;
  }
  code "(FP + $v)" {
    LD(C2); UL; ADD(C2,FP);
    PLK(p); PLD(S,C0); MSR(S,S); PUL;
    LK(STACK); ADR(C2); ST(C0); UL;
  }
  code "S($v)" {
    LD(C2); UL;
    PLK(p); PLD(S,C0); MSR(S,S); PUL;
    LK(STACK); ADR(C2); ST(C0); UL;
  }
  code "D($v)" {
    LD(C2); UL;
    PLK(p); PLD(S,C0); MSR(S,S); PUL;
    LK(DATA); ADR(C2); ST(C0); UL;
  }
  code "E($v)" {
    LD(C2); UL;
    PLK(p); PLD(S,C0); MSR(S,S); PUL;
    LK(EXTRA); ADR(C2); ST(C0); UL;
  }
}

instruction IN.RW "$r, $m" {
  $ReadPortWord(a);
}

instruction IN.IW "$v, $m" {
  LD(MB);
  $ReadPortWord(MB);
}

macro(bits:5) ReadPortDword(p) {
  code "$R" {
    UL;
    PLK(p); PLD(A,m0); PLD(S,m1); MSR(S,S); PUL;
  }
  code "[$r]" {
    UL;
    PLK(p); PLD(A,C0); PLD(S,C1); MSR(S,S); PUL;
    LKR(m); ADR(m); ST(C0); ST(C1); UL;
  }
  code "[$r + $v]" {
    LD(C2); UL; ADD(C2,m);
    PLK(p); PLD(A,C0); PLD(S,C1); MSR(S,S); PUL;
    LKR(m); ADR(C2); ST(C0); ST(C1); UL;
  }
  code "[SP]" {
    UL;
    PLK(p); PLD(A,C0); PLD(S,C1); MSR(S,S); PUL;
    LK(STACK); ADR(SP); ST(C0); ST(C1); UL;
  }
  code "[SP + $v]" {
    LD(C2); UL; ADD(C2,SP);
    PLK(p); PLD(A,C0); PLD(S,C1); MSR(S,S); PUL;
    LK(STACK); ADR(C2); ST(C0); ST(C1); UL;
  }
  code "[FP]" {
    UL;
    PLK(p); PLD(A,C0); PLD(S,C1); MSR(S,S); PUL;
    LK(STACK); ADR(FP); ST(C0); ST(C1); UL;
  }
  code "[FP + $v]" {
    LD(C2); UL; ADD(C2,FP);
    PLK(p); PLD(A,C0); PLD(S,C1); MSR(S,S); PUL;
    LK(STACK); ADR(C2); ST(C0); ST(C1); UL;
  }
  code "S[$v]" {
    LD(C2); UL;
    PLK(p); PLD(A,C0); PLD(S,C1); MSR(S,S); PUL;
    LK(STACK); ADR(C2); ST(C0); ST(C1); UL;
  }
  code "D[$v]" {
    LD(C2); UL;
    PLK(p); PLD(A,C0); PLD(S,C1); MSR(S,S); PUL;
    LK(DATA); ADR(C2); ST(C0); ST(C1); UL;
  }
  code "E[$v]" {
    LD(C2); UL;
    PLK(p); PLD(A,C0); PLD(S,C1); MSR(S,S); PUL;
    LK(EXTRA); ADR(C2); ST(C0); ST(C1); UL;
  }
}

instruction IN.RD "$r, $m" {
  $ReadPortDword(a);
}

instruction IN.ID "$v, $m" {
  LD(MB);
  $ReadPortDword(MB);
}

################################################################################
## INS <port> <dst>
##
## Cycles: 4+
## ZSCO: -X--
##
## Variants:
##    INS.RW <reg>    <reg>
##    INS.RW <reg>    <word-address>
##    INS.IW <0..255> <reg>
##    INS.IW <0..255> <word-address>
##    INS.RD <reg>    <dreg>
##    INS.RD <reg>    <dword-address>
##    INS.ID <0..255> <dreg>
##    INS.ID <0..255> <dword-address>
##
## Reads from the specified port if the port status is set and writes to the
## specified register or memory address. "S" flag is set if a word was read,
## otherwise it is cleared.
################################################################################

macro(bits:5) ReadPortWordIfReady(p) {
  code "$r" {
    UL;
    PLK(p); PLD(TS,m); MSR(S,S); PUL;
  }
  code "($r)" {
    UL;
    PLK(p); PLD(TS,C0); MSR(S,S); PUL;
    JC(S,@ready);
    END;
  @ready:
    LKR(m); ADR(m); ST(C0); UL;
  }
  code "($r + $v)" {
    LD(C2); UL;
    PLK(p); PLD(TS,C0); MSR(S,S); PUL;
    JC(S,@ready);
    END;
  @ready:
    ADD(C2,m);
    LKR(m); ADR(C2); ST(C0); UL;
  }
  code "(SP)" {
    UL;
    PLK(p); PLD(TS,C0); MSR(S,S); PUL;
    JC(S,@ready);
    END;
  @ready:
    LK(STACK); ADR(SP); ST(C0); UL;
  }
  code "(SP + $v)" {
    LD(C2); UL;
    PLK(p); PLD(TS,C0); MSR(S,S); PUL;
    JC(S,@ready);
    END;
  @ready:
    ADD(C2,SP);
    LK(STACK); ADR(C2); ST(C0); UL;
  }
  code "(FP)" {
    UL;
    PLK(p); PLD(TS,C0); MSR(S,S); PUL;
    JC(S,@ready);
    END;
  @ready:
    LK(STACK); ADR(FP); ST(C0); UL;
  }
  code "(FP + $v)" {
    LD(C2); UL;
    PLK(p); PLD(TS,C0); MSR(S,S); PUL;
    JC(S,@ready);
    END;
  @ready:
    ADD(C2,FP);
    LK(STACK); ADR(C2); ST(C0); UL;
  }
  code "S($v)" {
    LD(C2); UL;
    PLK(p); PLD(TS,C0); MSR(S,S); PUL;
    JC(S,@ready);
    END;
  @ready:
    LK(STACK); ADR(C2); ST(C0); UL;
  }
  code "D($v)" {
    LD(C2); UL;
    PLK(p); PLD(TS,C0); MSR(S,S); PUL;
    JC(S,@ready);
    END;
  @ready:
    LK(DATA); ADR(C2); ST(C0); UL;
  }
  code "E($v)" {
    LD(C2); UL;
    PLK(p); PLD(TS,C0); MSR(S,S); PUL;
    JC(S,@ready);
    END;
  @ready:
    LK(EXTRA); ADR(C2); ST(C0); UL;
  }
}

instruction INS.RW "$r, $m" {
  $ReadPortWordIfReady(a);
}

instruction INS.IW "$v, $m" {
  LD(MB);
  $ReadPortWordIfReady(MB);
}

macro(bits:5) ReadPortDwordIfReady(p) {
  code "$R" {
    UL;
    PLK(p); PLD(TA,m0); PLD(TS,m1); MSR(S,S); PUL;
  }
  code "[$r]" {
    UL;
    PLK(p); PLD(TA,C0); PLD(TS,C1); MSR(S,S); PUL;
    JC(S,@ready);
    END;
  @ready:
    LKR(m); ADR(m); ST(C0); ST(C1); UL;
  }
  code "[$r + $v]" {
    LD(C2); UL;
    PLK(p); PLD(TA,C0); PLD(TS,C1); MSR(S,S); PUL;
    JC(S,@ready);
    END;
  @ready:
    ADD(C2,m);
    LKR(m); ADR(C2); ST(C0); ST(C1); UL;
  }
  code "[SP]" {
    UL;
    PLK(p); PLD(TA,C0); PLD(TS,C1); MSR(S,S); PUL;
    JC(S,@ready);
    END;
  @ready:
    LK(STACK); ADR(SP); ST(C0); ST(C1); UL;
  }
  code "[SP + $v]" {
    LD(C2); UL;
    PLK(p); PLD(TA,C0); PLD(TS,C1); MSR(S,S); PUL;
    JC(S,@ready);
    END;
  @ready:
    ADD(C2,SP);
    LK(STACK); ADR(C2); ST(C0); ST(C1); UL;
  }
  code "[FP]" {
    UL;
    PLK(p); PLD(TA,C0); PLD(TS,C1); MSR(S,S); PUL;
    JC(S,@ready);
    END;
  @ready:
    LK(STACK); ADR(FP); ST(C0); ST(C1); UL;
  }
  code "[FP + $v]" {
    LD(C2); UL;
    PLK(p); PLD(TA,C0); PLD(TS,C1); MSR(S,S); PUL;
    JC(S,@ready);
    END;
  @ready:
    ADD(C2,FP);
    LK(STACK); ADR(C2); ST(C0); ST(C1); UL;
  }
  code "S[$v]" {
    LD(C2); UL;
    PLK(p); PLD(TA,C0); PLD(TS,C1); MSR(S,S); PUL;
    JC(S,@ready);
    END;
  @ready:
    LK(STACK); ADR(C2); ST(C0); ST(C1); UL;
  }
  code "D[$v]" {
    LD(C2); UL;
    PLK(p); PLD(TA,C0); PLD(TS,C1); MSR(S,S); PUL;
    JC(S,@ready);
    END;
  @ready:
    LK(DATA); ADR(C2); ST(C0); ST(C1); UL;
  }
  code "E[$v]" {
    LD(C2); UL;
    PLK(p); PLD(TA,C0); PLD(TS,C1); MSR(S,S); PUL;
    JC(S,@ready);
    END;
  @ready:
    LK(EXTRA); ADR(C2); ST(C0); ST(C1); UL;
  }
}

instruction INS.RD "$r, $m" {
  $ReadPortDwordIfReady(a);
}

instruction INS.ID "$v, $m" {
  LD(MB);
  $ReadPortDwordIfReady(MB);
}

################################################################################
## INR <port> <address>
##
## Cycles: 5+
## ZSCO: -X--
##
## Variants:
##    INR.RW <reg>    <word-address>
##    INR.IW <0..255> <word-address>
##    INR.RD <reg>    <dword-address>
##    INR.ID <0..255> <dword-address>
##
## Reads up to R7 words from the specified port as long as port status is set
## before each read and writes sequentially starting at the specified memory
## address. R7 is set to the number of words *not* read. The "S" flag is set
## if all words/dwords were read (R7 == 0), otherwise it is cleared.
################################################################################

macro(bits:5) ReadPortWordRepeat(p) {
  code "($r)" {
    UL;
    MSS(S); MSR(_,S);
    CMP(R7,C0);
    JC(Z,@done);
    MOV(C2,m);
  @read:
    PLK(p); PLD(TS,C0); MSR(S,S); PUL;
    JC(NS,@done);
    LKR(m); ADR(C2); ST(C0); LAD(C2); UL;
    JD(R7,@read);
  @done:
    END;
  }
  code "($r + $v)" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(R7,C0);
    JC(Z,@done);
    ADD(C2,m);
  @read:
    PLK(p); PLD(TS,C0); MSR(S,S); PUL;
    JC(NS,@done);
    LKR(m); ADR(C2); ST(C0); LAD(C2); UL;
    JD(R7,@read);
  @done:
    END;
  }
  code "(SP)" {
    UL;
    MSS(S); MSR(_,S);
    CMP(R7,C0);
    JC(Z,@done);
    MOV(C2,SP);
  @read:
    PLK(p); PLD(TS,C0); MSR(S,S); PUL;
    JC(NS,@done);
    LK(STACK); ADR(C2); ST(C0); LAD(C2); UL;
    JD(R7,@read);
  @done:
    END;
  }
  code "(SP + $v)" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(R7,C0);
    JC(Z,@done);
    ADD(C2,SP);
  @read:
    PLK(p); PLD(TS,C0); MSR(S,S); PUL;
    JC(NS,@done);
    LK(STACK); ADR(C2); ST(C0); LAD(C2); UL;
    JD(R7,@read);
  @done:
    END;
  }
  code "(FP)" {
    UL;
    MSS(S); MSR(_,S);
    CMP(R7,C0);
    JC(Z,@done);
    MOV(C2,FP);
  @read:
    PLK(p); PLD(TS,C0); MSR(S,S); PUL;
    JC(NS,@done);
    LK(STACK); ADR(C2); ST(C0); LAD(C2); UL;
    JD(R7,@read);
  @done:
    END;
  }
  code "(FP + $v)" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(R7,C0);
    JC(Z,@done);
    ADD(C2,FP);
  @read:
    PLK(p); PLD(TS,C0); MSR(S,S); PUL;
    JC(NS,@done);
    LK(STACK); ADR(C2); ST(C0); LAD(C2); UL;
    JD(R7,@read);
  @done:
    END;
  }
  code "S($v)" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(R7,C0);
    JC(Z,@done);
  @read:
    PLK(p); PLD(TS,C0); MSR(S,S); PUL;
    JC(NS,@done);
    LK(STACK); ADR(C2); ST(C0); LAD(C2); UL;
    JD(R7,@read);
  @done:
    END;
  }
  code "D($v)" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(R7,C0);
    JC(Z,@done);
  @read:
    PLK(p); PLD(TS,C0); MSR(S,S); PUL;
    JC(NS,@done);
    LK(DATA); ADR(C2); ST(C0); LAD(C2); UL;
    JD(R7,@read);
  @done:
    END;
  }
  code "E($v)" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(R7,C0);
    JC(Z,@done);
  @read:
    PLK(p); PLD(TS,C0); MSR(S,S); PUL;
    JC(NS,@done);
    LK(EXTRA); ADR(C2); ST(C0); LAD(C2); UL;
    JD(R7,@read);
  @done:
    END;
  }
}

instruction INR.RW "$r, $m" {
  $ReadPortWordRepeat(a);
}

instruction INR.IW "$v, $m" {
  LD(MB);
  $ReadPortWordRepeat(MB);
}

macro(bits:5) ReadPortDwordRepeat(p) {
  code "[$r]" {
    UL;
    MSS(S); MSR(_,S);
    CMP(R7,C0);
    JC(Z,@done);
    MOV(C2,m);
  @read:
    PLK(p); PLD(TA,C0); PLD(TS,C1); MSR(S,S); PUL;
    JC(NS,@done);
    LKR(m); ADR(C2); ST(C0); ST(C1); LAD(C2); UL;
    JD(R7,@read);
  @done:
    END;
  }
  code "[$r + $v]" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(R7,C0);
    JC(Z,@done);
    ADD(C2,m);
  @read:
    PLK(p); PLD(TA,C0); PLD(TS,C1); MSR(S,S); PUL;
    JC(NS,@done);
    LKR(m); ADR(C2); ST(C0); ST(C1); LAD(C2); UL;
    JD(R7,@read);
  @done:
    END;
  }
  code "[SP]" {
    UL;
    MSS(S); MSR(_,S);
    CMP(R7,C0);
    JC(Z,@done);
    MOV(C2,SP);
  @read:
    PLK(p); PLD(TA,C0); PLD(TS,C1); MSR(S,S); PUL;
    JC(NS,@done);
    LK(STACK); ADR(C2); ST(C0); ST(C1); LAD(C2); UL;
    JD(R7,@read);
  @done:
    END;
  }
  code "[SP + $v]" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(R7,C0);
    JC(Z,@done);
    ADD(C2,SP);
  @read:
    PLK(p); PLD(TA,C0); PLD(TS,C1); MSR(S,S); PUL;
    JC(NS,@done);
    LK(STACK); ADR(C2); ST(C0); ST(C1); LAD(C2); UL;
    JD(R7,@read);
  @done:
    END;
  }
  code "[FP]" {
    UL;
    MSS(S); MSR(_,S);
    CMP(R7,C0);
    JC(Z,@done);
    MOV(C2,FP);
  @read:
    PLK(p); PLD(TA,C0); PLD(TS,C1); MSR(S,S); PUL;
    JC(NS,@done);
    LK(STACK); ADR(C2); ST(C0); ST(C1); LAD(C2); UL;
    JD(R7,@read);
  @done:
    END;
  }
  code "[FP + $v]" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(R7,C0);
    JC(Z,@done);
    ADD(C2,FP);
  @read:
    PLK(p); PLD(TA,C0); PLD(TS,C1); MSR(S,S); PUL;
    JC(NS,@done);
    LK(STACK); ADR(C2); ST(C0); ST(C1); LAD(C2); UL;
    JD(R7,@read);
  @done:
    END;
  }
  code "S[$v]" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(R7,C0);
    JC(Z,@done);
  @read:
    PLK(p); PLD(TA,C0); PLD(TS,C1); MSR(S,S); PUL;
    JC(NS,@done);
    LK(STACK); ADR(C2); ST(C0); ST(C1); LAD(C2); UL;
    JD(R7,@read);
  @done:
    END;
  }
  code "D[$v]" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(R7,C0);
    JC(Z,@done);
  @read:
    PLK(p); PLD(TA,C0); PLD(TS,C1); MSR(S,S); PUL;
    JC(NS,@done);
    LK(DATA); ADR(C2); ST(C0); ST(C1); LAD(C2); UL;
    JD(R7,@read);
  @done:
    END;
  }
  code "E[$v]" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(R7,C0);
    JC(Z,@done);
  @read:
    PLK(p); PLD(TA,C0); PLD(TS,C1); MSR(S,S); PUL;
    JC(NS,@done);
    LK(EXTRA); ADR(C2); ST(C0); ST(C1); LAD(C2); UL;
    JD(R7,@read);
  @done:
    END;
  }
}

instruction INR.RD "$r, $m" {
  $ReadPortDwordRepeat(a);
}

instruction INR.ID "$v, $m" {
  LD(MB);
  $ReadPortDwordRepeat(MB);
}

################################################################################
## OUT <port> <register>
##
## Cycles: 4+
## ZSCO: -1--
##
## Variants:
##    OUT.RW <reg>    <word-value>
##    OUT.IW <0..255> <word-value>
##    OUT.RD <reg>    <dword-value>
##    OUT.ID <0..255> <dword-value>
##
## Unconditionally writes the specified value to the specified port.
################################################################################

macro(bits:5) WritePortWord(p) {
  code "$r" {
    UL;
    PLK(p); PST(S,m); PUL;
    MSS(S); MSR(_,S);
  }
  code "($r)" {
    UL;
    LKR(m); ADR(m); LD(C0); UL;
    PLK(p); PST(S,C0); PUL;
    MSS(S); MSR(_,S);
  }
  code "($r + $v)" {
    LD(C2); UL; ADD(C2,m);
    LKR(m); ADR(C2); LD(C0); UL;
    PLK(p); PST(S,C0); PUL;
  }
  code "(SP)" {
    UL;
    LK(STACK); ADR(SP); LD(C0); UL;
    PLK(p); PST(S,C0); PUL;
    MSS(S); MSR(_,S);
  }
  code "(SP + $v)" {
    LD(C2); UL; ADD(C2,SP);
    LK(STACK); ADR(C2); LD(C0); UL;
    PLK(p); PST(S,C0); PUL;
    MSS(S); MSR(_,S);
  }
  code "(FP)" {
    UL;
    LK(STACK); ADR(FP); LD(C0); UL;
    PLK(p); PST(S,C0); PUL;
    MSS(S); MSR(_,S);
  }
  code "(FP + $v)" {
    LD(C2); UL; ADD(C2,FP);
    LK(STACK); ADR(C2); LD(C0); UL;
    PLK(p); PST(S,C0); PUL;
    MSS(S); MSR(_,S);
  }
  code "$v" {
    LD(C0); UL;
    PLK(p); PST(S,C0); PUL;
    MSS(S); MSR(_,S);
  }
  code "S($v)" {
    LD(C2); UL;
    LK(STACK); ADR(C2); LD(C0); UL;
    PLK(p); PST(S,C0); PUL;
    MSS(S); MSR(_,S);
  }
  code "D($v)" {
    LD(C2); UL;
    LK(DATA); ADR(C2); LD(C0); UL;
    PLK(p); PST(S,C0); PUL;
    MSS(S); MSR(_,S);
  }
  code "E($v)" {
    LD(C2); UL;
    LK(EXTRA); ADR(C2); LD(C0); UL;
    PLK(p); PST(S,C0); PUL;
    MSS(S); MSR(_,S);
  }
}

instruction OUT.RW "$r, $m" {
  $WritePortWord(a);
}

instruction OUT.IW "$v, $m" {
  LD(MB);
  $WritePortWord(MB);
}

macro(bits:5) WritePortDword(p) {
  code "$R" {
    UL;
    PLK(p); PST(A,m0); PST(S,m1); PUL;
  }
  code "[$r]" {
    UL;
    LKR(m); ADR(m); LD(C0); LD(C1); UL;
    PLK(p); PST(A,C0); PST(S,C1); PUL;
    MSS(S); MSR(_,S);
  }
  code "[$r + $v]" {
    LD(C2); UL; ADD(C2,m);
    LKR(m); ADR(C2); LD(C0); LD(C1); UL;
    PLK(p); PST(A,C0); PST(S,C1); PUL;
    MSS(S); MSR(_,S);
  }
  code "[SP]" {
    UL;
    LK(STACK); ADR(SP); LD(C0); LD(C1); UL;
    PLK(p); PST(A,C0); PST(S,C1); PUL;
    MSS(S); MSR(_,S);
  }
  code "[SP + $v]" {
    LD(C2); UL; ADD(C2,SP);
    LK(STACK); ADR(C2); LD(C0); LD(C1); UL;
    PLK(p); PST(A,C0); PST(S,C1); PUL;
    MSS(S); MSR(_,S);
  }
  code "[FP]" {
    UL;
    LK(STACK); ADR(FP); LD(C0); LD(C1); UL;
    PLK(p); PST(A,C0); PST(S,C1); PUL;
    MSS(S); MSR(_,S);
  }
  code "[FP + $v]" {
    LD(C2); UL; ADD(C2,FP);
    LK(STACK); ADR(C2); LD(C0); LD(C1); UL;
    PLK(p); PST(A,C0); PST(S,C1); PUL;
    MSS(S); MSR(_,S);
  }
  code "$V" {
    LD(C0); LD(C1); UL;
    PLK(p); PST(A,C0); PST(S,C1); PUL;
    MSS(S); MSR(_,S);
  }
  code "S[$v]" {
    LD(C2); UL;
    LK(STACK); ADR(C2); LD(C0); LD(C1); UL;
    PLK(p); PST(A,C0); PST(S,C1); PUL;
    MSS(S); MSR(_,S);
  }
  code "D[$v]" {
    LD(C2); UL;
    LK(DATA); ADR(C2); LD(C0); LD(C1); UL;
    PLK(p); PST(A,C0); PST(S,C1); PUL;
    MSS(S); MSR(_,S);
  }
  code "E[$v]" {
    LD(C2); UL;
    LK(EXTRA); ADR(C2); LD(C0); LD(C1); UL;
    PLK(p); PST(A,C0); PST(S,C1); PUL;
    MSS(S); MSR(_,S);
  }
}

instruction OUT.RD "$r, $m" {
  $WritePortDword(a);
}

instruction OUT.ID "$v, $m" {
  LD(MB);
  $WritePortDword(MB);
}

################################################################################
## OUTS <port> <register>
##
## Cycles: 4+
## ZSCO: -X--
##
## Variants:
##    OUTS.RW <reg>    <word-value>
##    OUTS.IW <0..255> <word-value>
##    OUTS.RD <reg>    <dword-value>
##    OUTS.ID <0..255> <dword-value>
##
## Writes the specified value to the specified port if the port status is not
## set. Sets the "S" flag if a value was written.
################################################################################

macro(bits:5) WritePortWordIfReady(p) {
  code "$r" {
    UL;
    PLK(p); PST(TS,m); PUL;
    MSX(S); MSR(S,S);
  }
  code "($r)" {
    UL;
    LKR(m); ADR(m); LD(C0); UL;
    PLK(p); PST(TS,C0); PUL;
    MSX(S); MSR(S,S);
  }
  code "($r + $v)" {
    LD(C2); UL; ADD(C2,m);
    LKR(m); ADR(C2); LD(C0); UL;
    PLK(p); PST(TS,C0); PUL;
    MSX(S); MSR(S,S);
  }
  code "(SP)" {
    UL;
    LK(STACK); ADR(SP); LD(C0); UL;
    PLK(p); PST(TS,C0); PUL;
    MSX(S); MSR(S,S);
  }
  code "(SP + $v)" {
    LD(C2); UL; ADD(C2,SP);
    LK(STACK); ADR(C2); LD(C0); UL;
    PLK(p); PST(TS,C0); PUL;
    MSX(S); MSR(S,S);
  }
  code "(FP)" {
    UL;
    LK(STACK); ADR(FP); LD(C0); UL;
    PLK(p); PST(TS,C0); PUL;
    MSX(S); MSR(S,S);
  }
  code "(FP + $v)" {
    LD(C2); UL; ADD(C2,FP);
    LK(STACK); ADR(C2); LD(C0); UL;
    PLK(p); PST(TS,C0); PUL;
    MSX(S); MSR(S,S);
  }
  code "$v" {
    LD(C0); UL;
    PLK(p); PST(TS,C0); PUL;
    MSX(S); MSR(S,S);
  }
  code "S($v)" {
    LD(C2); UL;
    LK(STACK); ADR(C2); LD(C0); UL;
    PLK(p); PST(TS,C0); PUL;
    MSX(S); MSR(S,S);
  }
  code "D($v)" {
    LD(C2); UL;
    LK(DATA); ADR(C2); LD(C0); UL;
    PLK(p); PST(TS,C0); PUL;
    MSX(S); MSR(S,S);
  }
  code "E($v)" {
    LD(C2); UL;
    LK(EXTRA); ADR(C2); LD(C0); UL;
    PLK(p); PST(TS,C0); PUL;
    MSX(S); MSR(S,S);
  }
}

instruction OUTS.RW "$r, $m" {
  $WritePortWordIfReady(a);
}

instruction OUTS.IW "$v, $m" {
  LD(MB);
  $WritePortWordIfReady(MB);
}

macro(bits:5) WritePortDwordIfReady(p) {
  code "$R" {
    UL;
    PLK(p); PST(A,m0); PST(S,m1); PUL;
    MSX(S); MSR(S,S);
  }
  code "[$r]" {
    UL;
    LKR(m); ADR(m); LD(C0); LD(C1); UL;
    PLK(p); PST(TA,C0); PST(TS,C1); PUL;
    MSX(S); MSR(S,S);
  }
  code "[$r + $v]" {
    LD(C2); UL; ADD(C2,m);
    LKR(m); ADR(C2); LD(C0); LD(C1); UL;
    PLK(p); PST(TA,C0); PST(TS,C1); PUL;
    MSX(S); MSR(S,S);
  }
  code "[SP]" {
    UL;
    LK(STACK); ADR(SP); LD(C0); LD(C1); UL;
    PLK(p); PST(TA,C0); PST(TS,C1); PUL;
    MSX(S); MSR(S,S);
  }
  code "[SP + $v]" {
    LD(C2); UL; ADD(C2,SP);
    LK(STACK); ADR(C2); LD(C0); LD(C1); UL;
    PLK(p); PST(TA,C0); PST(TS,C1); PUL;
    MSX(S); MSR(S,S);
  }
  code "[FP]" {
    UL;
    LK(STACK); ADR(FP); LD(C0); LD(C1); UL;
    PLK(p); PST(TA,C0); PST(TS,C1); PUL;
    MSX(S); MSR(S,S);
  }
  code "[FP + $v]" {
    LD(C2); UL; ADD(C2,FP);
    LK(STACK); ADR(C2); LD(C0); LD(C1); UL;
    PLK(p); PST(TA,C0); PST(TS,C1); PUL;
    MSX(S); MSR(S,S);
  }
  code "$V" {
    LD(C0); LD(C1); UL;
    PLK(p); PST(TA,C0); PST(TS,C1); PUL;
    MSX(S); MSR(S,S);
  }
  code "S[$v]" {
    LD(C2); UL;
    LK(STACK); ADR(C2); LD(C0); LD(C1); UL;
    PLK(p); PST(TA,C0); PST(TS,C1); PUL;
    MSX(S); MSR(S,S);
  }
  code "D[$v]" {
    LD(C2); UL;
    LK(DATA); ADR(C2); LD(C0); LD(C1); UL;
    PLK(p); PST(TA,C0); PST(TS,C1); PUL;
    MSX(S); MSR(S,S);
  }
  code "E[$v]" {
    LD(C2); UL;
    LK(EXTRA); ADR(C2); LD(C0); LD(C1); UL;
    PLK(p); PST(TA,C0); PST(TS,C1); PUL;
    MSX(S); MSR(S,S);
  }
}

instruction OUTS.RD "$r, $m" {
  $WritePortDwordIfReady(a);
}

instruction OUTS.ID "$v, $m" {
  LD(MB);
  $WritePortDwordIfReady(MB);
}

################################################################################
## OUTR <port> <register>
##
## Cycles: 4+
## ZSCO: -X--
##
## Variants:
##    OUTR.RW <reg>    <word-address>
##    OUTR.IW <0..255> <word-address>
##    OUTR.RD <reg>    <dword-address>
##    OUTR.ID <0..255> <dword-address>
##
## Writes up to R7 values to the specified port while the port status is not
## set. R7 holds the number of values not written. Sets the "S" flag if all
## values were was written (R7 is zero).
################################################################################

macro(bits:5) WritePortWordRepeat(p) {
  code "($r)" {
    UL;
    MSS(S); MSR(_,S);
    CMP(R7,C0);
    JC(Z,@done);
    MOV(C2,m);
  @write:
    LKR(m); ADR(C2); LD(C0); LAD(C2); UL;
    PLK(p); PST(TS,C0); PUL;
    MSX(S); MSR(S,S);
    JD(R7, @write);
  @done:
    END;
  }
  code "($r + $v)" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(R7,C0);
    JC(Z,@done);
    ADD(C2,m);
  @write:
    LKR(m); ADR(C2); LD(C0); LAD(C2); UL;
    PLK(p); PST(TS,C0); PUL;
    MSX(S); MSR(S,S);
    JD(R7, @write);
  @done:
    END;
  }
  code "(SP)" {
    UL;
    MSS(S); MSR(_,S);
    CMP(R7,C0);
    JC(Z,@done);
    MOV(C2,SP);
  @write:
    LK(STACK); ADR(SP); LD(C0); LAD(C2); UL;
    PLK(p); PST(TS,C0); PUL;
    MSX(S); MSR(S,S);
    JD(R7, @write);
  @done:
    END;
  }
  code "(SP + $v)" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(R7,C0);
    JC(Z,@done);
    ADD(C2,SP);
  @write:
    LK(STACK); ADR(C2); LD(C0); LAD(C2); UL;
    PLK(p); PST(TS,C0); PUL;
    MSX(S); MSR(S,S);
    JD(R7, @write);
  @done:
    END;
  }
  code "(FP)" {
    UL;
    MSS(S); MSR(_,S);
    CMP(R7,C0);
    JC(Z,@done);
    MOV(C2,FP);
  @write:
    LK(STACK); ADR(C2); LD(C0); LAD(C2); UL;
    PLK(p); PST(TS,C0); PUL;
    MSX(S); MSR(S,S);
    JD(R7, @write);
  @done:
    END;
  }
  code "(FP + $v)" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(R7,C0);
    JC(Z,@done);
    ADD(C2,FP);
  @write:
    LK(STACK); ADR(C2); LD(C0); LAD(C2); UL;
    PLK(p); PST(TS,C0); PUL;
    MSX(S); MSR(S,S);
    JD(R7, @write);
  @done:
    END;
  }
  code "S($v)" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(R7,C0);
    JC(Z,@done);
  @write:
    LK(STACK); ADR(C2); LD(C0); LAD(C2); UL;
    PLK(p); PST(TS,C0); PUL;
    MSX(S); MSR(S,S);
    JD(R7, @write);
  @done:
    END;
  }
  code "D($v)" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(R7,C0);
    JC(Z,@done);
  @write:
    LK(DATA); ADR(C2); LD(C0); LAD(C2); UL;
    PLK(p); PST(TS,C0); PUL;
    MSX(S); MSR(S,S);
    JD(R7, @write);
  @done:
    END;
  }
  code "E($v)" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(R7,C0);
    JC(Z,@done);
  @write:
    LK(EXTRA); ADR(C2); LD(C0); LAD(C2); UL;
    PLK(p); PST(TS,C0); PUL;
    MSX(S); MSR(S,S);
    JD(R7, @write);
  @done:
    END;
  }
}

instruction OUTR.RW "$r, $m" {
  $WritePortWordRepeat(a);
}

instruction OUTR.IW "$v, $m" {
  LD(MB);
  $WritePortWordRepeat(MB);
}

macro(bits:5) WritePortDwordRepeat(p) {
  code "[$r]" {
    UL;
    MSS(S); MSR(_,S);
    CMP(R7,C0);
    JC(Z,@done);
    MOV(C2,m);
  @write:
    LKR(m); ADR(C2); LD(C0); LD(C1); LAD(C2); UL;
    PLK(p); PST(TA,C0); PST(TS,C1); PUL;
    MSX(S); MSR(S,S);
    JD(R7, @write);
  @done:
    END;
  }
  code "[$r + $v]" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(R7,C0);
    JC(Z,@done);
    ADD(C2,m);
  @write:
    LKR(m); ADR(C2); LD(C0); LD(C1); LAD(C2); UL;
    PLK(p); PST(TA,C0); PST(TS,C1); PUL;
    MSX(S); MSR(S,S);
    JD(R7, @write);
  @done:
    END;
  }
  code "[SP]" {
    UL;
    MSS(S); MSR(_,S);
    CMP(R7,C0);
    JC(Z,@done);
    MOV(C2,SP);
  @write:
    LK(STACK); ADR(SP); LD(C0); LD(C1); LAD(C2); UL;
    PLK(p); PST(TA,C0); PST(TS,C1); PUL;
    MSX(S); MSR(S,S);
    JD(R7, @write);
  @done:
    END;
  }
  code "[SP + $v]" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(R7,C0);
    JC(Z,@done);
    ADD(C2,SP);
  @write:
    LK(STACK); ADR(C2); LD(C0); LD(C1); LAD(C2); UL;
    PLK(p); PST(TA,C0); PST(TS,C1); PUL;
    MSX(S); MSR(S,S);
    JD(R7, @write);
  @done:
    END;
  }
  code "[FP]" {
    UL;
    MSS(S); MSR(_,S);
    CMP(R7,C0);
    JC(Z,@done);
    MOV(C2,FP);
  @write:
    LK(STACK); ADR(C2); LD(C0); LD(C1); LAD(C2); UL;
    PLK(p); PST(TA,C0); PST(TS,C1); PUL;
    MSX(S); MSR(S,S);
    JD(R7, @write);
  @done:
    END;
  }
  code "[FP + $v]" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(R7,C0);
    JC(Z,@done);
    ADD(C2,FP);
  @write:
    LK(STACK); ADR(C2); LD(C0); LD(C1); LAD(C2); UL;
    PLK(p); PST(TA,C0); PST(TS,C1); PUL;
    MSX(S); MSR(S,S);
    JD(R7, @write);
  @done:
    END;
  }
  code "S[$v]" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(R7,C0);
    JC(Z,@done);
  @write:
    LK(STACK); ADR(C2); LD(C0); LD(C1); LAD(C2); UL;
    PLK(p); PST(TA,C0); PST(TS,C1); PUL;
    MSX(S); MSR(S,S);
    JD(R7, @write);
  @done:
    END;
  }
  code "D[$v]" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(R7,C0);
    JC(Z,@done);
  @write:
    LK(DATA); ADR(C2); LD(C0); LD(C1); LAD(C2); UL;
    PLK(p); PST(TA,C0); PST(TS,C1); PUL;
    MSX(S); MSR(S,S);
    JD(R7, @write);
  @done:
    END;
  }
  code "E[$v]" {
    LD(C2); UL;
    MSS(S); MSR(_,S);
    CMP(R7,C0);
    JC(Z,@done);
  @write:
    LK(EXTRA); ADR(C2); LD(C0); LD(C1); LAD(C2); UL;
    PLK(p); PST(TA,C0); PST(TS,C1); PUL;
    MSX(S); MSR(S,S);
    JD(R7, @write);
  @done:
    END;
  }
}

instruction OUTR.RD "$r, $m" {
  $WritePortDwordRepeat(a);
}

instruction OUTR.ID "$v, $m" {
  LD(MB);
  $WritePortDwordRepeat(MB);
}

